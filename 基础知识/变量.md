# 变量

在 Rust 中，创建变量一般不说变量声明，而说成**变量绑定**。

**变量绑定（binding）** 就是把一个值和一个变量名关联起来，相当于其他语言中**声明一个带初始值的变量** 

## 类型标注

变量绑定时，可以显式标注类型，如果没有显式标注，Rust 会自动推导；如果推导不出来，必须显式标注，否则会报错

```rust
let x: i32 = 10;    // 显式标注类型
let y = 20;         // 类型推导为 i32
```

## 可变性

默认绑定的变量是不可变的，尝试赋值会报错

```rust
fn main() {
    let x = 5;      // 不可变绑定
    println!("x = {}", x);

    // x = 6;       // 错误：cannot assign twice to immutable variable
}
```

可以使用 `mut` 关键字声明可变绑定

```rust
fn main() {
    let mut x = 5;  // 可变绑定
    println!("x = {}", x);
    x = 6;          // 可以修改
    println!("x = {}", x);
}
```

## 解构绑定

解构绑定实际上是模式匹配，在 let 语句中 Rust 用**模式匹配**把复杂数据解构提取并绑定到变量

### 元组解构

```rust
let (a, b, c) = (1, 2, 3);
println!("a = {}, b = {}, c = {}", a, b, c);
```

### 数组解构

```rust
let [x, y, z] = [10, 20, 30];
println!("x = {}, y = {}, z = {}", x, y, z);
```

### 结构体解构

```rust
struct Point { x: i32, y: i32 }
let p = Point { x: 3, y: 4 };
let Point { x, y } = p;
println!("x = {}, y = {}", x, y);
```

> 模式匹配后续会有专门的章节，这里只简单介绍


## 作用域

在 Rust 中，作用域就是一对 **花括号 `{}` 块** 。作用域可以嵌套，内层作用域可以访问外层作用域，反之则不行

```rust
fn main() {
    let x = 5;
    {
        let y = 10;
        println!("x = {}", x); // ✅ ok
        println!("y = {}", y); // ✅ ok
    }

    println!("x = {}", x); // ✅ ok
    // println!("y = {}", y); ❌ 编译错误：y 不在作用域中
}
```

当变量离开作用域，Rust 会自动 **drop（释放资源）**

## 变量遮蔽

同一个变量名可以重新绑定数据，新绑定的数据可以是任意类型。这种行为被称为**变量遮蔽**

遮蔽原则：

- 同作用域变量遮蔽，原变量被销毁，不可再访问
- 不同作用域遮蔽，仅当前作用域生效；作用域结束，被遮蔽变量恢复可见

```rust
fn main() {
    let _a = 1; // s1
    let mut _a = String::from("hello"); // s2
    {
        let _a = [1, 2, 3]; // s3
        println!("{:?}", _a);
    }
    _a.push_str("world"); // s4
    println!("{:?}", _a);
    drop(_a);
    // println!("{}", _a); // s5
}
```

代码执行过程：

1. s2处：重新绑定，s1被销毁
2. s3处：重新绑定，s2被遮蔽
3. s4处：s2重新可见
4. s5处：如果去掉注释会报错，为什么？参考遮蔽原则


## 常量

`const` 声明，必须指定类型，编译时确定，始终不可变，类型必须显式标注

```rust
const MAX_POINTS: u32 = 100_000;

// Syntax Error: missing type for `const` or `static`
const MAX_POINTS = 100_000; // 错误：类型未标注
```

```
Syntax Error: missing type for `const` or `static`
```

## 静态变量

用 `static` 声明，全局可用，默认不可变，类型必须显式标注

```rust
static GREETING: &str = "Hello, world!";
static mut COUNTER: u32 = 0;  // 可变静态变量，需要 unsafe 访问

// Syntax Error: missing type for `const` or `static`
static GREETING = "Hello, world!"; // 错误：类型未标注
```

