## 什么是引用

引用是 **指向某个值的指针**，但不拥有该值的所有权。
使用引用可以**安全地访问或修改数据而不转移所有权**。

```rust
let s = String::from("hello");
let r = &s; // r 是 s 的引用
println!("{}", r); // hello
```

* `&` 表示不可变引用。
* 引用是轻量的，本质就是指针，受 Rust 的安全检查。

## 借用（Borrowing）

- 借用就是**使用引用访问值**。
- Rust 将引用称为借用，遵循严格规则，保证内存安全。
- 引用是类型，借用是行为和规则。

> 重点：**引用（reference）是一个具体的指针类型**

```rust
fn print_name(name: &String) {
    println!("{}", name);
}
```

* `&String` 是一个 **引用类型**
* 当传入这个引用时，对原始 `String` 的 **借用** 发生了

### 不可变借用（&T）

```rust
fn print_length(s: &String) {
    println!("Length: {}", s.len());
}

fn main() {
    let s = String::from("hello");
    print_length(&s); // 借用 s
    println!("{}", s); // s 仍然有效
}
```

特点：

* 借用期间不可修改原值。
* 可以同时有多个不可变借用。
* 不转移所有权。


### 可变借用（&mut T）

```rust
fn add_exclamation(s: &mut String) {
    s.push('!');
}

fn main() {
    let mut s = String::from("hello");
    add_exclamation(&mut s);
    println!("{}", s); // hello!
}
```

特点：

* 可以修改被借用的值。
* **同一时间只能有一个可变借用**。
* 可变借用与不可变借用不能共存。


### 借用规则总结

1. 一个值可以有任意多个不可变引用（`&T`）。
2. 或者一个可变引用（`&mut T`）。
3. 不可同时存在可变和不可变引用。
4. 借用不会释放所有权，函数返回后原值仍有效。


## 借用与函数

### 函数参数借用

```rust
fn calculate_length(s: &String) -> usize {
    s.len()
}

fn main() {
    let s = String::from("hello");
    let len = calculate_length(&s);
    println!("Length: {}", len);
    println!("{}", s); // s 仍然有效
}
```

* 通过引用借用函数参数，不会移动所有权。
* 函数内可以读取值，但不能修改（除非是 `&mut`）。

### 可变引用函数

```rust
fn append_world(s: &mut String) {
    s.push_str(" world");
}

fn main() {
    let mut s = String::from("hello");
    append_world(&mut s);
    println!("{}", s); // hello world
}
```


## 引用与切片

引用可以用在数组和字符串切片上：

```rust
let s = String::from("hello");
let slice = &s[0..2]; // slice 是 &str 引用
println!("{}", slice); // he
```

* 切片是对原数据的一种引用，不拥有所有权。
* 可以避免拷贝，提高性能。


## 生命周期（Lifetime）

引用的**作用域不能超过被引用的值**，否则会悬垂：

```rust
fn main() {
    let r;
    {
        let s = String::from("hello");
        r = &s; // ❌ s 在外层作用域无效
    }
    // println!("{}", r); // ❌ 编译错误
}
```

* 生命周期确保引用总是有效。
* 函数返回引用时，需要用 **生命周期标注**：

```rust
fn longest<'a>(s1: &'a str, s2: &'a str) -> &'a str {
    if s1.len() > s2.len() { s1 } else { s2 }
}
```

`'a` 表示引用的生命周期，Rust 编译器会检查引用安全性。



## 借用与所有权机制关系

| 特性      | 不可变借用 (&T) | 可变借用 (&mut T) |
| ------- | ----------- | -------------- |
| 可修改值    | ❌           | ✅              |
| 同时借用数   | 任意多个        | 仅 1 个          |
| 与原所有权关系 | 不转移所有权      | 不转移所有权         |
| 函数参数使用  | 安全读取        | 安全修改           |



## 总结

1. **引用 = 借用**，不转移所有权。
2. **不可变引用**可多，不能修改值。
3. **可变引用**只有一个，能修改值。
4. 引用不能悬垂，需要生命周期保证。
5. 切片本质上是对数组或字符串的引用。
6. 借用规则保证 Rust **内存安全、无数据竞争**。
