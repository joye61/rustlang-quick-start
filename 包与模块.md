下面这份笔记把 Rust 里的“包（package）—> 箱（crate）—> 模块（module）—> 项（item）”从上到下一次讲透。每个知识点后都有「记忆要点」，并配有能直接套用的示例。内容基于 2018+ 版式（你现在几乎一定在用），避免陈旧写法。

---

# 1. 整体鸟瞰：Package / Crate / Module 的关系

* **Package（包）**：一个由 `Cargo.toml` 管理的**项目单元**。包里可以包含**至多一个库 crate**，以及**任意多个二进制 crate**。
* **Crate（箱）**：**编译与链接的最小单位**。每次 `rustc` 编译的就是一个 crate。crate 有二进制（可执行）和库（静态/rlib、cdylib、proc-macro 等）之分。
* **Module（模块）**：在 crate 内用来**组织命名空间**与**控制可见性**的树状结构；不独立编译。
* **Item（项）**：模块里的元素：函数、结构体、枚举、常量、类型别名、trait、impl、宏等。

**示意图**

```
Package (有 Cargo.toml)
 ├─ Crate: src/lib.rs         (库)
 ├─ Crate: src/main.rs        (默认二进制)
 └─ 多个 Crate: src/bin/*.rs  (更多二进制)
      └─ 每个 Crate 内部再是 Module 树
```

**记忆要点**：包是外层“项目”，crate 是编译单元，module 是 crate 内的目录树/命名空间。

---

# 2. Package（包）

* 由 `Cargo.toml` 定义包名、版本、依赖、特性（features）、构建目标等。
* 一个包**最多一个**库 crate：默认根在 `src/lib.rs`。
* 一个包**可以有多个**二进制 crate：

  * 默认一个在 `src/main.rs`
  * 额外的放在 `src/bin/*.rs`，或在 `Cargo.toml` 的 `[[bin]]` 指定路径和名称。

**最小示例**

```
myapp/
├─ Cargo.toml
└─ src/
   ├─ lib.rs          # (可选) 库 crate
   ├─ main.rs         # (可选) 默认二进制 crate
   └─ bin/
      ├─ tool.rs      # 额外二进制 crate
      └─ analyze.rs
```

**Cargo.toml 片段**

```toml
[package]
name = "myapp"
version = "0.1.0"
edition = "2021"

[dependencies]
rand = "0.8"

[[bin]]
name = "tool"
path = "src/bin/tool.rs"
```

**记忆要点**：`Cargo.toml` 决定“包”；`src/lib.rs`（库）和若干 `src/main.rs`/`src/bin/*.rs`（可执行）决定包里有哪些 crate。

---

# 3. Crate（箱）与 crate root

* **crate root（根）**：一个源文件，是整个 crate 的入口：

  * 库 crate：`src/lib.rs`
  * 二进制 crate：`src/main.rs` 或 `src/bin/foo.rs`
* `crate` 也是**路径前缀**，表示**从根开始的绝对路径**。

**示例**

```rust
// src/lib.rs  —— 这是库 crate 的根
pub mod math;      // 声明模块
pub use math::add; // 重新导出对外 API

// src/main.rs —— 这是二进制 crate 的根
fn main() {
    println!("Hello from binary crate!");
}
```

**记忆要点**：每个 crate 只有一个根文件；`crate::` 是“从根开始”的绝对路径。

---

# 4. Module（模块）声明与文件布局

模块有两种写法：

1. **内联模块**（代码就在当前文件里）

```rust
mod utils {
    pub fn greet() { println!("hi"); }
}
```

2. **文件/目录模块**（模块内容在外部文件）

```rust
mod utils; // 查找同级的 `utils.rs` 或 `utils/mod.rs`
```

* 2018+ 版式支持：

  * `mod foo;` 会在同级找 `foo.rs`，或在 `foo/` 目录下找 `mod.rs`。
  * 继续嵌套：`foo/bar.rs` 或 `foo/bar/mod.rs` 都可。

**目录示例**

```
src/lib.rs
src/utils.rs               // mod utils;
src/net/mod.rs             // mod net;
src/net/http.rs            // pub mod http;
src/net/tcp.rs
```

**lib.rs**

```rust
pub mod utils;
pub mod net;
```

**net/mod.rs**

```rust
pub mod http;
pub mod tcp;
```

**记忆要点**：`mod name;` = 去找 `name.rs` 或 `name/mod.rs`。写在 `{ ... }` 里的就是内联模块。

---

# 5. 可见性与访问控制（pub / pub(...)）

* **默认私有**：模块及其内部项默认仅在**父模块**内可见。
* `pub`：对**父模块之外**可见（是否对外“公开”，还取决于上层路径是否可达）。
* **受限可见性**：

  * `pub(crate)`：整个 crate 内可见
  * `pub(super)`：对父模块可见
  * `pub(in path)`：对指定模块路径范围内可见

**结构体与枚举的特殊规则**

* `pub struct S { pub x: i32, y: i32 }`：**字段**默认私有，需逐一 `pub`。
* `pub enum E { A, B }`：**枚举变体**在枚举 `pub` 后**自动是公有**。

**示例**

```rust
mod a {
    pub(crate) mod inner {
        pub(super) fn only_parent_sees() {}
        pub fn anyone_in_crate_sees() {}
        pub(in crate::a) fn only_a_sees() {}
    }
    pub use inner::anyone_in_crate_sees as expose;
}
```

**记忆要点**：私有是默认；struct 字段要单独 `pub`；enum 变体随 enum 一起公开；可用 `pub(crate)/pub(super)/pub(in …)` 精细化控制。

---

# 6. 路径与 `use`：绝对、相对、重命名、glob

* **绝对路径**：从 `crate::` 或外部 crate 名开始。
* **相对路径**：从 `self::`、`super::` 或当前模块开始。
* `use` 引入路径到当前作用域；可在**模块或函数内**使用。
* `as` 重命名，避免冲突或缩短名字。
* `use foo::{bar, baz};` 支持**聚合**导入。
* `use foo::*;` **glob 导入**，少用，易冲突。
* 函数内 `use` 仅在该函数可见，常用于局部简化。

**示例**

```rust
// 绝对路径
use crate::net::http::Client;
// 相对路径
use super::super::utils::greet;
// 重命名
use std::io::Result as IoResult;
// 聚合
use std::{fmt, mem};
// 函数内 use
fn run() {
    use std::cmp::Ordering;
    let _x: Ordering = Ordering::Equal;
}
```

**记忆要点**：`crate::` 从根，`self::` 当前，`super::` 父级；`use` 可重命名与聚合；glob 慎用。

---

# 7. 重新导出与对外 API 设计（`pub use` / Prelude）

* `pub use`：对外**重定向导出**，隐藏内部层次，让使用者得到**平坦且稳定**的 API。
* **Prelude** 模式：提供一个 `prelude` 模块，聚合常用项，供用户 `use your_crate::prelude::*;`。

**示例：对外平滑 API**

```rust
// lib.rs
mod net { pub mod http { pub struct Client; } }
pub use net::http::Client; // 外部直接用 your_crate::Client
```

**示例：自定义 prelude**

```rust
// lib.rs
pub mod prelude {
    pub use crate::math::add;
    pub use crate::net::http::Client;
}
```

**记忆要点**：`pub use` 是“出口整形器”；prelude 是一组“常用导出”的集合。

---

# 8. 现代文件规则与属性（2018+）

* **不再必须** `mod.rs`；`foo.rs` / `foo/mod.rs` 都可。
* 罕见场景可用 `#[path="some/odd/name.rs"] mod x;` 自定义文件路径。
* 建议：**一模块一文件/目录**，层级清晰。

**记忆要点**：优先用简洁的 `foo.rs` 与目录 `foo/*.rs`；`#[path]` 仅用在特殊布局。

---

# 9. 多 Crate 工程：Workspace 与路径依赖

* **Workspace**：多个包共享 `Cargo.lock`、目标目录、统一管理依赖与版本。
* `Cargo.toml`（根）用 `[workspace]` + `members` 声明成员。
* 成员间可用**路径依赖**（`path = "../utils"`），形成多 crate 组合。

**示例（根 `Cargo.toml`）**

```toml
[workspace]
members = ["crates/corelib", "crates/cli"]
```

**cli/Cargo.toml**

```toml
[package]
name = "cli"
version = "0.1.0"
edition = "2021"

[dependencies]
corelib = { path = "../corelib" }
```

**记忆要点**：workspace 管理多包；成员间用 `path` 互相依赖，开发大型工程更爽。

---

# 10. 条件编译与测试模块

* `#[cfg(...)]` 与 `#[cfg_attr(...)]` 控制平台/特性编译。
* 约定俗成：在同文件末尾写测试模块：

  ```rust
  #[cfg(test)]
  mod tests {
      use super::*;
      #[test]
      fn it_works() { assert_eq!(2+2, 4); }
  }
  ```

**记忆要点**：`#[cfg(test)] mod tests;` 放本文件的单元测；`cfg` 配置让模块按平台/特性出现与否。

---

# 11. 宏与模块（简要）

* 2018+：**大多数情况不需要** `#[macro_use] extern crate ...`。
* 宏像普通项一样通过路径导入：`use mycrate::macros::some_macro;`（或直接 `mycrate::some_macro!()`）。
* 导出宏给下游用：在定义处加 `#[macro_export]`（它会把宏导到 crate 根；更推荐提供模块化宏并 `pub use`）。

**记忆要点**：宏的导入/导出尽量与普通 `use`/`pub use` 一致；避免旧式 `macro_use`。

---

# 12. 文档注释与属性（crate / module 级）

* **外部文档注释**：`///` 放在项的上方。
* **内部文档注释**：`//!` 放在**文件顶部**，描述“本 crate/本模块”的总体说明（写在 `lib.rs`/模块文件顶部很常见）。
* 常见 crate 级属性：

  * `#![deny(missing_docs)]` 强制所有公有项写文档
  * `#![allow(dead_code)]` 等
* 模块、项上也可放 `#[allow(...)]`/`#[deny(...)]` 等。

**记忆要点**：`///` 描述项，`//!` 描述当前文件代表的“整体”；crate 顶部可放全局属性。

---

# 13. 常见陷阱与最佳实践

* **私有类型外泄**：公有函数签名里**不能**出现私有类型（会触发 `private_in_public`）。
* **过度 glob**：`use foo::*;` 易冲突、可读性差；对外 API 更建议 `pub use` 精选导出。
* **循环依赖与耦合**：模块间相互引用过多，考虑**上提公共模块**或**拆分为独立 crate**。
* **文件命名与层次**：一个模块一文件/目录，避免超长文件；公共 API 做好门面（`pub use`）。
* **结构体字段可见性**：对外库 API 中的 `pub struct`，只暴露必要字段；其他用方法访问以利于封装。
* **二进制与库分离**：可执行逻辑尽量调用库 crate，复用性与测试性都更好。

**记忆要点**：API 封装与“门面导出”比什么都重要；少用 `*`，多用显式导出。

---

# 14. 综合案例：一个“计算 + HTTP 客户端”包

**目标**：

* 包名 `app`，内含：

  * 库 crate：`calc`（对外导出 `add`、`Client`）
  * 二进制 crate：`app`（调用库）

**目录**

```
app/
├─ Cargo.toml
├─ src/
│  ├─ lib.rs            # 库 crate 根
│  ├─ main.rs           # 二进制 crate 根
│  ├─ math/
│  │  ├─ mod.rs
│  │  └─ add.rs
│  └─ net/
│     ├─ mod.rs
│     └─ http.rs
```

**Cargo.toml**

```toml
[package]
name = "app"
version = "0.1.0"
edition = "2021"

[dependencies]
# 示例：依赖重命名（如果需要）
# serde_json_alias = { package = "serde_json", version = "1" }
```

**src/lib.rs（库根）**

```rust
//! 这个库对外提供数学与 HTTP 能力的统一门面

mod math;
mod net;

// 对外门面：重导出精选 API
pub use math::add;
pub use net::http::Client;

// 还可以提供 prelude
pub mod prelude {
    pub use crate::add;
    pub use crate::Client;
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn add_works() { assert_eq!(add(2, 3), 5); }
}
```

**src/math/mod.rs**

```rust
pub mod add;
```

**src/math/add.rs**

```rust
pub fn add(a: i32, b: i32) -> i32 { a + b }
```

**src/net/mod.rs**

```rust
pub mod http;
```

**src/net/http.rs**

```rust
pub struct Client {
    pub base: String,       // 演示：公开字段
    token: Option<String>,  // 私有字段
}

impl Client {
    pub fn new(base: impl Into<String>) -> Self {
        Self { base: base.into(), token: None }
    }
    pub fn with_token(mut self, t: impl Into<String>) -> Self {
        self.token = Some(t.into());
        self
    }
    pub(crate) fn sign(&self, path: &str) -> String {
        // 仅 crate 内部可见的“签名”方法
        format!("{}/{}?sig=xxx", self.base, path)
    }
}
```

**src/main.rs（二进制）**

```rust
use app::{add, Client};           // 直接从库门面导入
// 或：use app::prelude::*;       // 用 prelude 一把梭

fn main() {
    println!("2 + 3 = {}", add(2, 3));

    let cli = Client::new("https://api.example.com").with_token("abc");
    // 这里不能直接调用 crate 内的 pub(crate) 方法：
    // let url = cli.sign("ping"); // 编译错误（签名是内部 API）
    println!("Client base = {}", cli.base);
}
```

**要点速记**

* 用 `pub use` 在 `lib.rs` 做**门面导出**，让二进制/下游使用者得到简洁 API。
* 通过字段与方法的 `pub`/`pub(crate)` 控制封装边界。

---

# 15. 依赖与外部 crate 命名（加餐）

* 2018+ 不需要 `extern crate`。直接 `use rand::Rng;` 即可，只要 `Cargo.toml` 里有 `rand = "..."`
* **依赖重命名**（避免名字冲突或更短的 crate 名）：

  ```toml
  [dependencies]
  my_serde = { package = "serde", version = "1" }
  ```

  然后代码里用 `use my_serde::Serialize;`

**记忆要点**：依赖名 = crate 名；要改名在 `Cargo.toml` 用 `package = "原名"`。

---

# 16. crate 类型与 `crate-type`（加餐）

* 默认：库 crate 生成 `rlib`；二进制 crate 生成可执行文件。
* 如需 `cdylib`/`staticlib`/`proc-macro` 等，可在 `Cargo.toml` 指定：

  ```toml
  [lib]
  crate-type = ["rlib", "cdylib"]
  ```

**记忆要点**：需要给 C/Swift 等调用时常用 `cdylib`；写宏库用 `proc-macro`。

---

## 末尾总复盘

* **包** ≈ 项目（`Cargo.toml`）；**crate** 是编译单元（`src/lib.rs` / `src/main.rs` / `src/bin/*.rs`）；**模块**是在 crate 内组织与封装代码的树。
* 使用 `mod` 建树、`pub` 控制可见、`use` 管理路径、`pub use` 打造门面。
* 2018+ 文件布局简洁：`foo.rs`/`foo/mod.rs` 都行；测试模块 `#[cfg(test)] mod tests` 写在本文件。
* 多 crate 工程用 **workspace**；对外 API 要**稳**、**平**、**清晰**。

如果你想，我可以把你的现有项目结构贴出来，我帮你把模块树和门面导出设计好，并标注每个文件应放哪些代码与可见性标记。
