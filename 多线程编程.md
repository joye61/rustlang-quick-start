## 多线程编程

### 二、基础：创建你的第一个线程（30 秒上手）
Rust 用 `std::thread` 模块创建线程，核心函数是 `spawn`。

#### 示例 1：启动一个线程
```rust
use std::thread;

fn main() {
    let handle = thread::spawn(|| {
        println!("Hello from another thread!");
    });

    // 等待子线程结束
    handle.join().unwrap();
    println!("Main thread done.");
}

```

- **关键点**：
  - `thread::spawn(|| { ... })`：启动新线程，里面是 **闭包**（类似匿名函数）
  - `handle.join()`：主线程 **等待子线程结束**（不加这句，主线程结束时子线程会被杀掉！）

> ⚠️ **常见坑**：忘记 `join()` → 子线程没执行完就被终止。**记住：线程像孩子，主线程是家长，必须等孩子回家！**

---

### 三、核心难题：如何安全共享数据？（所有权系统大显神威）
#### 线程不能直接借用外部变量
```rust
fn main() {
    let s = String::from("Rust");
    let handle = thread::spawn(|| {
        println!("子线程: {}", s); // 编译错误！
    });
    handle.join().unwrap();
}
```
**错误信息**：  
`error[E0373]: closure may outlive the current function`  
（闭包生命周期可能比当前函数长，Rust 不允许这样借用数据）

> **为什么？**  
> `s` 可能在创建它的作用域结束后被清理，而子线程还在用 `s`，导致 **悬垂指针**（访问无效内存）

- thread::spawn 默认要求传入的闭包是 'static 生命周期 的（意思是闭包里不能捕获仅存在于当前函数栈上的引用）。
- s 是 main 函数里的局部变量，生命周期只到 main 结束。
- 如果闭包捕获了 s 的引用，那么子线程可能比 main 活得久，就会出现悬垂引用（dangling reference）的风险。
- Rust 编译器在编译期阻止了这种不安全情况，所以报错。

Rust 为了保证线程安全，要求：

- 闭包中使用的外部数据必须 'static（不依赖栈上的临时数据），
- 或者你显式转移所有权（move 闭包）。

#### 作用域线程：`thread::scope`

```rust
use std::thread;

fn main() {
    let msg = String::from("Hi");
    thread::scope(|s| {
        s.spawn(|| {
            println!("{}", msg);
        });
    });
}
```

可以安全地借用局部变量，不必 'static。作用域结束前会自动等待子线程结束。

#### 解法 1：用 `move` 关键字转移所有权（最常用！）
```rust
fn main() {
    let s = String::from("Rust");
    // 用 move 把 s 的所有权转移到子线程
    let handle = thread::spawn(move || {
        println!("子线程: {}", s); // 正确！s 现在属于子线程
    });
    handle.join().unwrap();
    // println!("{}", s); // 错误！s 已被移走
}
```
- **`move` 的作用**：强制闭包获取外部变量的所有权（而非借用）
- **代价**：主线程不能再用 `s`（所有权转移了）

#### 解法 2：但我想多个线程共享数据怎么办？
→ 这时需要 **同步原语**（Sync Primitives），下面重点讲！

---

### 四、同步原语：安全共享数据的三大法宝
#### 法宝 1：`Mutex`（互斥锁）—— "厕所单间锁"
- **作用**：确保同一时间 **只有一个线程** 能访问数据
- **生活比喻**：公共厕所单间，门上挂锁。进去时锁门（`lock`），出来时开门（自动释放）

##### 示例 2：用 `Mutex` 共享计数器
```rust
use std::sync::Mutex;
use std::thread;

fn main() {
    // 创建一个被 Mutex 保护的计数器
    let counter = Mutex::new(0);
    let mut handles = vec![];

    // 启动 5 个线程
    for _ in 0..5 {
        let handle = thread::spawn(move || {
            // 加锁（如果锁被占用，线程会阻塞等待）
            let mut num = counter.lock().unwrap();
            *num += 1; // 修改数据
            // 锁在这里自动释放（RAII 机制，离开作用域即释放）
        });
        handles.push(handle);
    }

    // 等待所有线程结束
    for handle in handles {
        handle.join().unwrap();
    }

    println!("最终计数: {}", *counter.lock().unwrap());
}
```
**输出**：`最终计数: 5`（总是正确！）

- **关键点**：
  - `Mutex::new(0)`：创建带锁的数据
  - `counter.lock()`：尝试加锁（**阻塞**直到拿到锁）
  - **自动释放**：Rust 用 **RAII**（资源获取即初始化）确保锁在作用域结束时释放（不用手动 unlock！）
  - `.unwrap()`：处理可能的错误（如锁被污染）

> ⚠️ **死锁警告**：  
> 如果线程 A 拿着锁 1 等锁 2，线程 B 拿着锁 2 等锁 1 → **死锁**（程序卡死）  
> **避免技巧**：  
> 1. 锁的顺序一致（比如都先锁 1 再锁 2）  
> 2. 锁的范围尽量小（只锁必要代码）

---

#### 法宝 2：`Arc`（原子引用计数）—— "共享汽车钥匙"
- **问题**：`Mutex` 本身不能跨线程共享（因为不安全）
- **解法**：`Arc`（`Atomic Reference Counting`）让多个线程安全持有 `Mutex`
- **生活比喻**：共享汽车，`Arc` 是电子钥匙系统。每次借车（`clone`）计数+1，还车计数-1，归零时销毁车

##### 示例 3：`Arc` + `Mutex` 共享数据
```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    // 用 Arc 包裹 Mutex，使其可跨线程共享
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        // 每个线程拿到 counter 的一个克隆（引用计数+1）
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("最终计数: {}", *counter.lock().unwrap());
}
```
- **关键点**：
  - `Arc::new()`：创建可共享的智能指针
  - `Arc::clone(&counter)`：克隆指针（**不复制数据**，只增加引用计数）
  - **为什么需要 Arc**？  
    `Mutex` 实现了 `Send` 和 `Sync` trait，但普通 `Mutex` 不能跨线程传递（所有权问题）。`Arc` 提供线程安全的引用计数。

> 💡 **技术细节**：  
> - `Arc` 是 **原子操作**（CPU 指令级安全），避免多线程修改计数时出错  
> - 与 `Rc`（单线程引用计数）区别：`Rc` 不安全，多线程会崩溃

---

#### 法宝 3：`RwLock`（读写锁）—— "图书馆模式"
- **场景**：读多写少（比如配置数据）
- **规则**：
  - 任意数量线程可 **同时读**（`read`）
  - 写时 **独占**（`write`），其他读写阻塞
- **生活比喻**：图书馆  
  - 读者（read）：多人同时看书  
  - 作者（write）：修改书籍时，禁止所有人进入

##### 示例 4：用 `RwLock` 优化读操作
```rust
use std::sync::RwLock;
use std::thread;

fn main() {
    let data = RwLock::new(vec![1, 2, 3]);
    
    // 5 个读线程
    let mut readers = vec![];
    for _ in 0..5 {
        let data = data.clone();
        readers.push(thread::spawn(move || {
            let d = data.read().unwrap(); // 多个线程可同时读
            println!("读线程: {:?}", *d);
        }));
    }

    // 1 个写线程
    let writer = thread::spawn(move || {
        let mut d = data.write().unwrap(); // 写时独占
        d.push(4);
        println!("写线程: 已更新");
    });

    // 等待所有线程
    for r in readers {
        r.join().unwrap();
    }
    writer.join().unwrap();
}
```
**输出**（读线程可能并行执行）：
```
读线程: [1, 2, 3]
读线程: [1, 2, 3]
...（其他读线程）
写线程: 已更新
```
- **与 `Mutex` 对比**：  
  | 锁类型 | 读性能 | 写性能 | 适用场景 |
  |--------|--------|--------|----------|
  | `Mutex` | 低（每次只能一个线程） | 低 | 读写均衡 |
  | `RwLock` | 高（多读并发） | 低（写时阻塞所有） | 读多写少 |

> ⚠️ **注意**：  
> - 写锁优先级高，可能导致 **写饥饿**（一直有读线程，写线程等不到）  
> - 操作系统会调度，但极端情况需手动处理

---

### 五、更安全的方式：消息传递（Channels）
Rust **官方推荐**：优先用 **消息传递** 而非共享状态！  
核心：`std::sync::mpsc`（多生产者单消费者通道）

#### 生活比喻
- **通道** = 邮筒  
- **生产者** = 寄信人（`Sender`）  
- **消费者** = 收信人（`Receiver`）  
- **消息** = 信件（所有权转移，安全！）

##### 示例 5：生产者-消费者模型
```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    // 创建通道：tx 是发信端，rx 是收信端
    let (tx, rx) = mpsc::channel();

    // 启动消费者线程
    let handle = thread::spawn(move || {
        // rx.recv() 阻塞等待消息
        let msg = rx.recv().unwrap();
        println!("收到消息: {}", msg);
    });

    // 生产者发送消息
    tx.send("Hello from main!").unwrap();

    handle.join().unwrap();
}
```
**输出**：`收到消息: Hello from main!`

#### 高级用法：多生产者
```rust
let (tx, rx) = mpsc::channel();
let tx1 = tx.clone(); // 克隆发送端（多生产者）

thread::spawn(move || {
    tx.send("Hi from thread 1").unwrap();
});

thread::spawn(move || {
    tx1.send("Hi from thread 2").unwrap();
});

// 主线程接收所有消息
for msg in rx {
    println!("主接收: {}", msg);
}
```
- **关键特性**：
  - **所有权转移**：`send()` 后原变量失效（安全！）
  - **自动关闭**：所有 `Sender` 被丢弃后，`recv()` 返回 `Err`
  - **阻塞/非阻塞**：`recv()` 阻塞，`try_recv()` 立即返回

> 💡 **为什么推荐消息传递？**  
> - 无锁设计，避免死锁  
> - 数据所有权清晰（消息被消费后，发送方不能再用）  
> - 更符合 Rust 的所有权哲学

---

### 六、其他必备知识点（不遗漏！）
#### 1. 原子类型（`std::sync::atomic`）
- **场景**：简单类型（如计数器）无需锁
- **原理**：CPU 级原子指令（比 Mutex 轻量）
```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use std::thread;

fn main() {
    let counter = AtomicUsize::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = &counter;
        handles.push(thread::spawn(move || {
            counter.fetch_add(1, Ordering::Relaxed); // 原子操作
        }));
    }

    for h in handles {
        h.join().unwrap();
    }
    println!("计数: {}", counter.load(Ordering::Relaxed));
}
```
- **关键**：`Ordering` 参数（内存顺序），初学者用 `Relaxed` 即可

#### 2. 线程本地存储（`thread_local!`）
- **场景**：每个线程需要独立副本（如全局配置）
```rust
thread_local! {
    static LOCAL_DATA: RefCell<i32> = RefCell::new(0);
}

fn main() {
    thread::spawn(|| {
        LOCAL_DATA.with(|data| {
            *data.borrow_mut() = 100;
            println!("线程1: {}", *data.borrow());
        });
    }).join().unwrap();

    LOCAL_DATA.with(|data| {
        println!("主线程: {}", *data.borrow()); // 仍是0
    });
}
```
- **注意**：用 `RefCell` 实现内部可变性

#### 3. 线程 panic 处理
- 子线程 panic 不会直接导致主线程崩溃
- `join()` 返回 `Result`，可捕获错误
```rust
let handle = thread::spawn(|| {
    panic!("子线程炸了！");
});

match handle.join() {
    Ok(_) => println!("成功"),
    Err(e) => println!("子线程错误: {:?}", e),
}
```

#### 4. 避免常见陷阱
| 陷阱 | 解决方案 |
|------|----------|
| 忘记 `join()` | 总是保存 `JoinHandle` 并调用 `join()` |
| 锁范围过大 | 只锁必要代码（`let mut x = lock(); ...`） |
| 嵌套锁顺序不一致 | 固定锁顺序（如先 A 后 B） |
| 用 `Rc` 代替 `Arc` | 多线程必须用 `Arc` |

---

### 七、终极总结：Rust 多线程心法
1. **优先消息传递**（`mpsc`）：安全、简单、无死锁  
2. **共享状态次之**：  
   - 读多写少 → `RwLock` + `Arc`  
   - 均衡读写 → `Mutex` + `Arc`  
   - 简单类型 → `Atomic`  
3. **编译器是你的盟友**：  
   - 所有权规则在编译期消灭数据竞争  
   - 遇到错误别硬改，理解背后的安全逻辑  
4. **黄金法则**：  
   > "如果数据只能被一个线程访问，用 `move` 转移所有权；  
   > 如果多线程需要共享，用 `Arc` + 同步原语。"

---

### 附：完整练习项目（巩固所学）
```rust
// 任务：5 个生产者生成随机数，1 个消费者求和
use std::sync::mpsc;
use std::thread;
use std::time::Duration;
use rand::Rng;

fn main() {
    let (tx, rx) = mpsc::channel();
    
    // 启动消费者
    let consumer = thread::spawn(move || {
        let mut sum = 0;
        for num in rx {
            sum += num;
            println!("当前和: {}", sum);
            if sum > 100 { break; } // 达到阈值退出
        }
        sum
    });

    // 启动5个生产者
    for i in 0..5 {
        let tx = tx.clone();
        thread::spawn(move || {
            let mut rng = rand::thread_rng();
            for _ in 0..10 {
                let num = rng.gen_range(1..=10);
                tx.send(num).unwrap();
                thread::sleep(Duration::from_millis(100));
            }
            println!("生产者 {} 完成", i);
        });
    }

    // 主线程等待结果
    drop(tx); // 关闭发送端，否则消费者会无限等待
    let total = consumer.join().unwrap();
    println!("最终总和: {}", total);
}
```
> 注：运行前请先执行 `cargo add rand` 添加依赖
