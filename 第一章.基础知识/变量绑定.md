# 变量

在 Rust 中，**变量绑定（binding）** 就是把一个值和一个变量名关联起来，相当于其他语言中**声明一个带初始值的变量** 

## 类型标注

变量绑定时，可以显式标注类型，如果没有显式标注，Rust 会自动推导；如果推导不出来，必须显式标注，否则会报错

```rust
let x: i32 = 10;    // 显式标注类型
let y = 20;         // 类型推导为 i32
```

## 可变性

默认绑定的变量是不可变的，尝试赋值会报错

```rust
fn main() {
    let x = 5;      // 不可变绑定
    println!("x = {}", x);

    // x = 6;       // 错误：cannot assign twice to immutable variable
}
```

可以使用 `mut` 关键字声明可变绑定

```rust
fn main() {
    let mut x = 5;  // 可变绑定
    println!("x = {}", x);
    x = 6;          // 可以修改
    println!("x = {}", x);
}
```

## 作用域

在 Rust 中，作用域就是一对 **花括号 `{}` 块** 。作用域可以嵌套，内层作用域可以访问外层作用域的变量，反之则不行

```rust
fn main() {
    let x = 5;
    {
        let y = 10;
        println!("x = {}, y = {}", x, y); // 正确：可访问外层 x
    }
    // println!("{}", y); // 错误：y 超出作用域
}
```

当变量离开作用域，Rust 会自动 **drop（释放资源）**

---

## 解构绑定

解构绑定实际上是模式匹配，在 let 语句中 Rust 用**模式匹配**把复杂数据解构提取并绑定到变量

### 元组解构

```rust
let (a, b, c) = (1, 2, 3);
println!("a = {}, b = {}, c = {}", a, b, c);
```

### 数组解构

```rust
let [x, y, z] = [10, 20, 30];
println!("x = {}, y = {}, z = {}", x, y, z);
```

### 结构体解构

```rust
struct Point { x: i32, y: i32 }
let p = Point { x: 3, y: 4 };
let Point { x, y } = p;
println!("x = {}, y = {}", x, y);
```

> 模式匹配后续会有专门的章节，这里只简单介绍

---

## 变量遮蔽

同一个变量名可以重新绑定数据，新绑定的数据不需要参考旧数据类型。在 Rust 中，这种行为被称为**变量遮蔽**

遮蔽原则：

- 同一作用域内发生变量遮蔽时，原变量被立即移出作用域（或销毁），不可再访问
- 子作用域遮蔽父作用域变量时，仅在子作用域内生效；子作用域结束后，父作用域的变量恢复可见

```rust
fn main() {
    let _a = 1; // s1
    let mut _a = String::from("hello"); // s2
    {
        let _a = [1, 2, 3]; // s3
        println!("{:?}", _a);
    }
    _a.push_str("world"); // s4
    println!("{:?}", _a);
    drop(_a);
    // println!("{}", _a); // s5
}
```

代码执行过程：

1. s2处：重新绑定，s1被销毁
2. s3处：重新绑定，s2被遮蔽
3. s4处：s2重新可见
4. s5处：如果去掉注释会报错，为什么？参考遮蔽原则


## 常量

- 用 `const` 声明，必须指定类型
- 编译时确定，始终不可变

```rust
const MAX_POINTS: u32 = 100_000;
```

## 静态变量

- 用 `static` 声明，全局可用，默认不可变。

```rust
static GREETING: &str = "Hello, world!";
static mut COUNTER: u32 = 0;  // 可变静态变量，需要 unsafe 访问
```

