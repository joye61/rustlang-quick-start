# 作用域

**作用域** 就是变量、函数、模块等在程序中**能访问和起作用的范围**。可以理解为一对“**大括号 `{}`**”包围的“**可见区域**”


## 变量作用域

* 变量在 `{}` 中声明，只能在这个块中访问
* 块结束后，变量被自动销毁（drop）

```rust
fn main() {
    let x = 5;
    {
        let y = 10;
        println!("x = {}", x); // ✅ ok
        println!("y = {}", y); // ✅ ok
    }

    println!("x = {}", x); // ✅ ok
    // println!("y = {}", y); ❌ 编译错误：y 不在作用域中
}
```

## 作用域中的“遮蔽”

Rust 允许你使用**相同的变量名重新声明一个变量**，称为“**遮蔽（shadowing）**”

```rust
fn main() {
    let x = 5;
    let x = x + 1; // 遮蔽前一个 x
    {
        let x = x * 2; // 在新的作用域中再次遮蔽
        println!("内层 x = {}", x); // 12
    }
    println!("外层 x = {}", x); // 6
}
```

### 好处：

* 允许改变变量类型或值，而不需要另取名字
* 不会违反不可变性原则

---

## 生命周期与作用域

变量作用域也决定了它的**生命周期（lifetime）**

```rust
fn main() {
    let r;
    {
        let x = 5;
        r = &x;
    }
    // println!("{}", r); // ❌ 无效引用
}
```

> 生命周期错误本质是 **使用了已销毁的变量**


## 函数作用域

函数中定义的变量，只在该函数的作用域中可见

```rust
fn say_hi() {
    let msg = "hello";
    println!("{}", msg);
}

fn main() {
    say_hi();
    // println!("{}", msg); // ❌ msg 不在作用域中
}
```

---

## 条件语句中的作用域

`if`, `match`, `loop` 等控制结构会创建新的作用域

```rust
fn main() {
    let x = 10;

    if x > 5 {
        let y = x * 2;
        println!("y = {}", y); // ✅ ok
    }

    // println!("{}", y); // ❌ y 只在 if 块中有效
}
```

---

## 模块作用域

Rust 使用模块系统组织代码，不同模块间有**可见性控制**

```rust
mod math {
    pub fn add(a: i32, b: i32) -> i32 {
        a + b
    }

    fn hidden() {
        // 私有函数
    }
}

fn main() {
    let sum = math::add(2, 3); // ✅ ok
    // math::hidden(); // ❌ 编译错误：函数是私有的
}
```

> `pub` 表示公开（public），否则默认私有（private）


## 块表达式作用域

```rust
fn main() {
    let result = {
        let x = 3;
        x + 1
    };
    println!("result = {}", result); // 4
    // println!("{}", x); // ❌ x 不可见
}
```

花括号 `{}` 本身就是表达式块，返回最后一行的值


## `for`, `while`, `loop` 中的作用域

**每次**循环迭代都会创建一个新的作用域

```rust
fn main() {
    for i in 0..3 {
        let square = i * i;
        println!("square = {}", square);
    }
    // println!("{}", square); // ❌ 不在作用域中
}
```

---

## 静态作用域与变量遮蔽区别

```rust
fn main() {
    let x = 5;
    let x = "hello"; // ✅ OK：遮蔽，类型改变也允许
    println!("{}", x);
}
```

但如果用了 `mut`，就不能改变类型：

```rust
fn main() {
    let mut x = 5;
    // x = "hello"; // ❌ 错误：类型不匹配
}
```

## 作用域与资源释放（RAII）

Rust 使用 **作用域来自动管理资源释放**（RAII 模型）：**值在离开作用域时都会被自动 drop（释放）**，这是 Rust 内存安全的核心保障之一

```rust
fn main() {
    {
        let s = String::from("hello");
        println!("{}", s);
    } // 这里 s 被 drop，内存自动释放
}
```

### 自动 Drop 的原理：Drop Trait

Rust 的自动释放机制基于一个核心 trait：**`Drop`**

所有实现了 `Drop` trait 的类型，在离开作用域时会自动调用 `drop()` 方法

```rust
trait Drop {
    fn drop(&mut self);
}
```

### Drop 的执行顺序

当多个变量离开作用域时，**按声明的逆序**调用 `drop`：

```rust
fn main() {
    let a = String::from("A");
    let b = String::from("B");
    let c = String::from("C");
} // 执行顺序：c → b → a
```

> 原因：后声明的变量可能依赖先声明的变量，逆序释放更安全

### Drop 默认实现

你不需要手写 `impl Drop`，所有类型，只要在离开作用域时“拥有”需要清理的资源，就会自动触发 `Drop` 过程。Rust 编译器会为你的结构体**自动生成一个 `Drop` 实现**

只有当你需要**在释放前执行一些自定义逻辑**时，才需要手动实现。如果你手动实现了，先执行你写的 `drop()`，再自动清理

### 什么时候需要手动实现 `Drop`

只有当你需要**在释放前执行一些自定义逻辑**时，才需要手动实现。常见场景：

| 场景 | 示例 |
|------|------|
| 释放系统资源 | 关闭文件、网络连接、数据库连接 |
| 清理临时文件 | 删除创建的临时目录 |
| 记录日志 | “用户已退出”、“连接已断开” |
| 通知其他系统 | 发送注销消息 |

## 总结

| 类型        | 描述                   | 变量是否生效           |
| --------- | -------------------- | ---------------- |
| 块作用域 `{}` | 常规代码块                | 只在块内部生效          |
| 函数作用域     | 函数内部                 | 函数外部不可访问         |
| 控制结构作用域   | if/match/for 等创建的作用域 | 仅在结构体内部生效        |
| 模块作用域     | mod 定义的作用域           | 需用 `pub` 才能被外部访问 |
| 变量遮蔽      | 新变量同名覆盖旧变量           | 新变量拥有新的作用域       |