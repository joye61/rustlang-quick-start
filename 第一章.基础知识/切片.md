# Rust 中的切片类型详解（`[T]` 与 `&[T]`）

## 一句话定义：

> **切片（slice）是对一段连续内存中元素的引用，它没有所有权，长度在运行时确定**

典型类型：

* 不可变切片：`&[T]`
* 可变切片：`&mut [T]`

---

## 切片和数组的区别

| 类型         | 长度    | 是否拥有所有权 | 是否可变 | 用途     |
| ---------- | ----- | ------- | ---- | ------ |
| `[T; N]`   | 编译期固定 | 是       | 看声明  | 静态数组   |
| `&[T]`     | 运行期决定 | 否（是引用）  | 否    | 只读切片 ✅ |
| `&mut [T]` | 运行期决定 | 否       | 是    | 可变切片 ✅ |

## 切片基本使用

```rust
fn main() {
    let arr = [10, 20, 30, 40, 50];

    let slice1: &[i32] = &arr;           // 整个数组的不可变切片
    let slice2: &[i32] = &arr[1..4];     // 部分切片，包括索引1到3

    println!("slice1: {:?}", slice1);    // [10, 20, 30, 40, 50]
    println!("slice2: {:?}", slice2);    // [20, 30, 40]
}
```

## 切片类型的完整语法结构

```rust
&[T]        // 不可变切片
&mut [T]    // 可变切片
```

* `&[T]` 和 `&mut [T]` 都是对 `[T]` 类型的引用。
* `[T]` 是 **动态大小类型（DST）**，必须通过引用使用。

---

## 切片的常用操作方法（impl 在 `slice::[T]`）

```rust
let arr = [1, 2, 3, 4, 5];
let slice = &arr[1..4]; // [2, 3, 4]
```

| 方法                      | 说明                       |
| ----------------------- | ------------------------ |
| `len()`                 | 返回切片的长度                  |
| `is_empty()`            | 判断是否为空切片                 |
| `get(index)`            | 安全索引，返回 `Option<&T>`     |
| `get_mut(index)`        | 可变切片中获取 `&mut T`         |
| `first()` / `last()`    | 获取第一个 / 最后一个元素           |
| `split_at(index)`       | 返回两个切片，前一个是前 `index` 个元素 |
| `iter()` / `iter_mut()` | 迭代器                      |

示例：

```rust
let s = &arr[1..4]; // [2, 3, 4]
println!("第一个元素：{:?}", s.first()); // Some(2)
println!("长度：{}", s.len()); // 3
```

## 切片的传参场景

切片是非常常见的函数参数类型：

```rust
fn sum(slice: &[i32]) -> i32 {
    slice.iter().sum()
}

fn main() {
    let v = vec![1, 2, 3, 4];
    println!("{}", sum(&v)); // 传入切片
}
```

* 支持数组、Vec、字符串等的切片。
* 切片参数更灵活，不限制容器类型。


## 安全 vs 不安全访问

```rust
let s = &[1, 2, 3];

let a = s[0];          // 不安全，越界会 panic
let b = s.get(1);      // 安全访问，返回 Option<&T>
let c = s.get(10);     // None，而不会 panic
```


## 切片索引语法

```rust
&arr[a..b]     // 包含索引 a，排除 b（半开区间）
&arr[..b]      // 从开头到 b-1
&arr[a..]      // 从 a 到结尾
&arr[..]       // 整个数组
```

## 可变切片

```rust
let mut data = [1, 2, 3, 4];
let s = &mut data[1..3]; // s: &mut [i32]
s[0] = 10;
println!("{:?}", data); // [1, 10, 3, 4]
```

> 可变切片必须遵守 Rust 的“独占可变借用”规则（不能和原始引用并存）


## 切片与字符串（`&str`）

`&str` 实际上就是 `&[u8]` 上添加 UTF-8 语义的切片：

```rust
let s = "hello world"; // 类型是 &str，本质是 UTF-8 字节切片
let slice = &s[0..5];  // "hello"
```

字符串切片必须在合法的 UTF-8 边界上切割，否则会 panic。

---

## 切片是零成本抽象

切片在运行时只保存两个信息：

* 指针（起始地址）
* 长度

编译器在处理切片时会非常高效，**无运行时开销（zero-cost abstraction）**

---

## 切片在内存中的表示

```rust
// 假设 arr: [i32; 5]
let slice = &arr[1..4];
```

内部会表现为：

```text
struct Slice {
    ptr: *const i32, // 指向 arr[1]
    len: usize       // 长度是 3
}
```

## 总结

| 特性                  | 说明                                  |
| ------------------- | ----------------------------------- |
| `[T]`               | 动态大小类型，必须通过引用使用                     |
| `&[T]` / `&mut [T]` | 不可变 / 可变切片                          |
| 安全访问                | `.get()` / `.get_mut()` 返回 `Option` |
| 字符串切片               | `&str` 实质是 UTF-8 的 `&[u8]`          |
| 零成本抽象               | 切片只是指针+长度，无性能负担 ✅                   |