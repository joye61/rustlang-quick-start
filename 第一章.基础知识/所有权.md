## 什么是所有权（Ownership）

Rust 的 **所有权机制**是 Rust **内存安全和无需垃圾回收的核心**。
它的基本规则：

1. Rust 中的每个值都有一个 **所有者（owner）**。
2. 每个值 **同时只能有一个所有者**。
3. 当所有者离开作用域时，Rust 会 **自动释放内存**（drop）。

---

## 所有权转移（Move）

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1; // 所有权转移（move）

    // println!("{}", s1); // ❌ s1 已无效
    println!("{}", s2); // ✅ s2 拥有所有权
}
```

* 对 **非 Copy 类型**（如 `String`、`Vec`）赋值会 **move**。
* **基本类型**（整数、布尔、浮点）是 `Copy` 类型，赋值不会移动。

```rust
let x = 5;
let y = x; // x 可继续使用
println!("{}", x); // ✅
```

---

## 克隆（Clone）

如果想保留原值，可以 **显式克隆**：

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("{}", s1); // ✅
println!("{}", s2); // ✅
```

* `clone()` 会在堆上创建一个深拷贝。
* `copy` 是浅拷贝，仅对 `Copy` 类型自动发生。

---

## 借用（Borrowing）

### 不可变借用（&）

```rust
fn print_length(s: &String) {
    println!("Length: {}", s.len());
}

fn main() {
    let s = String::from("hello");
    print_length(&s); // 借用
    println!("{}", s); // s 依然可用
}
```

* 使用 `&` 借用，不转移所有权。
* 借用期间 **原值不可被修改（不可变借用）**。

---

### 可变借用（&mut）

```rust
fn add_exclamation(s: &mut String) {
    s.push('!');
}

fn main() {
    let mut s = String::from("hello");
    add_exclamation(&mut s);
    println!("{}", s); // hello!
}
```

* 使用 `&mut` 可修改借用的值。
* **同一时间只能有一个可变借用**，防止数据竞争。

---

### 借用规则总结

1. 在同一作用域中：

   * 可以有任意多个不可变借用（`&T`）。
   * 或者有一个可变借用（`&mut T`）。
   * 不可同时存在可变借用和不可变借用。
2. 借用不会释放所有权，函数返回后原值仍有效。

---

## 引用悬垂与生命周期

引用必须 **有效期小于或等于所有者的生命周期**。

```rust
fn longest<'a>(s1: &'a str, s2: &'a str) -> &'a str {
    if s1.len() > s2.len() { s1 } else { s2 }
}

fn main() {
    let a = String::from("long");
    let b = String::from("short");

    let result = longest(&a, &b);
    println!("{}", result);
}
```

* `'a` 是 **生命周期参数**，表示引用不能超过其所有者。
* 生命周期帮助 Rust 编译器 **保证引用有效性**。


## 所有权函数传参与返回

### 函数获取所有权

```rust
fn takes_ownership(s: String) {
    println!("{}", s);
}

fn main() {
    let s = String::from("hello");
    takes_ownership(s); // s 的所有权被移动
    // println!("{}", s); // ❌ s 已无效
}
```

### 函数返回所有权

```rust
fn gives_ownership() -> String {
    String::from("hello")
}

fn main() {
    let s1 = gives_ownership(); // 获得所有权
    println!("{}", s1);
}
```

### 借用避免所有权移动

```rust
fn calculate_length(s: &String) -> usize {
    s.len()
}

fn main() {
    let s = String::from("hello");
    let len = calculate_length(&s); // 借用
    println!("Length: {}", len);
    println!("{}", s); // s 依然可用
}
```

## 小结

| 概念        | 描述                        |
| --------- | ------------------------- |
| 所有权       | 每个值有一个 owner，作用域结束自动 drop |
| Move      | 非 Copy 类型赋值会转移所有权         |
| Clone     | 深拷贝，保留原值                  |
| Borrowing | 使用 & 或 \&mut 借用值，不转移所有权   |
| 不可变借用     | \&T，可同时多个，不可修改            |
| 可变借用      | \&mut T，同时只能一个，可修改        |
| 生命周期      | 引用不能超过所有者的有效期             |
| 函数参数/返回   | 所有权可以移动，也可以通过借用传递         |