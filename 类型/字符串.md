##  Rust 中的两大字符串类型

在 Rust 里，几乎所有字符串相关的操作都会涉及两个核心类型：

| 类型       | 所有权    | 存储位置        | 可变性 | 长度     | 用途     |
| -------- | ------ | ----------- | --- | ------ | ------ |
| `&str`   | **借用** | 只读内存（字面量）或堆 | 不可变 | 已知     | 只读视图   |
| `String` | **拥有** | 堆           | 可变  | 可增长/缩减 | 可编辑字符串 |

### 简单示例

```rust
let s1: &str = "hello";            // 字符串切片，指向静态只读数据
let mut s2: String = String::from("hello"); // 堆上可变字符串
s2.push_str(", world");            // 修改 String
println!("{} / {}", s1, s2);
```

**记忆要点**

* `&str`：只读引用，类似别人家的房子钥匙
* `String`：自己家的房子钥匙+土地证，想怎么改就怎么改（当然还要遵守 UTF-8 规则）


## 内部结构与底层表示

Rust 中的 `String` 实际是对 `Vec<u8>` 的封装，结构大致如下：

```
String {
    ptr: *u8,      // 指向堆中 UTF-8 数据
    len: usize,    // 当前使用的字节数
    capacity: usize // 分配的总字节数
}
```

而 `&str` 是一个**胖指针**：

```
&str {
    ptr: *u8,      // 指向 UTF-8 数据
    len: usize,    // 长度（字节数）
}
```

两者的 `len()` 都是**字节数**，而不是字符数。

### 示例：字节与字符数

```rust
let s = String::from("你好");
println!("len: {}", s.len());             // 6 字节
println!("chars: {}", s.chars().count()); // 2 个 Unicode 字符
```

**记忆要点**

* Rust 字符串都是 UTF-8 编码
* `len()` 是字节数，不是“字符”个数
* 中文、emoji 往往占多个字节


## 创建字符串的多种方式

### 创建 `String`

```rust
let s1 = String::new();               // 空字符串
let s2 = String::from("hello");       // 从 &str 创建
let s3 = "world".to_string();         // &str -> String
let s4 = "rust".to_owned();           // 等价于 to_string
let s5 = format!("{} {}", "hi", 2025);// 格式化生成
```

### 创建 `&str`

```rust
let s1: &str = "hello";               // 字面量，编译期固定
let s2 = &String::from("hi");         // &String 自动转成 &str
let s3 = &"world"[0..3];              // 切片（必须在 UTF-8 边界）
```

**记忆要点**

* `"..."` 总是 `&'static str`（静态切片）
* `String::from()` 和 `.to_string()` 是最常用的创建方法


## `String` ↔ `&str` 互转

```rust
let s = String::from("hello");

// String -> &str
let slice1: &str = &s;        // 自动解引用
let slice2 = s.as_str();

// &str -> String
let owned1 = slice1.to_string();
let owned2 = slice1.to_owned();
```

**记忆要点**

* 从 `String` 到 `&str` 是零成本（借用）
* 从 `&str` 到 `String` 会复制数据到堆


## 5. 常用修改操作（仅 `String` 支持）

```rust
let mut s = String::from("hi");

// 追加
s.push('!');                  // 加单个字符
s.push_str(" Rust");           // 加字符串切片

// 插入（索引必须是 UTF-8 边界）
s.insert(0, '*');
s.insert_str(1, "Hello");

// 删除
s.pop();                       // 删除最后一个字符
s.remove(0);                   // 删除指定位置的字符
s.truncate(2);                 // 截断到指定字节数
s.clear();                     // 清空

println!("{}", s);
```

**记忆要点**

* 所有索引操作必须在 UTF-8 边界，否则会 panic
* 删除、插入是按字节索引定位的，但返回/处理的是字符


## 6. 字符串拼接

### 用 `+` 运算符

```rust
let s1 = String::from("Hello");
let s2 = String::from("World");
let s3 = s1 + " " + &s2; // s1 被移动走，不能再用
```

### 用 `format!`

```rust
let s1 = String::from("Hello");
let s2 = String::from("World");
let s3 = format!("{} {}", s1, s2); // 不会移动 s1 和 s2
```

**记忆要点**

* `+` 会消耗左操作数（所有权移动）
* `format!` 适合保留原变量


## 7. 读取与遍历

```rust
let s = "Hello";

// 按字节
for b in s.bytes() {
    print!("{} ", b);
}

// 按 Unicode 字符
for c in s.chars() {
    print!("{} ", c);
}
```

**记忆要点**

* `bytes()` → `u8` 流
* `chars()` → Unicode 标量值（可能不是用户看到的“完整字符”）


## 8. 不支持直接索引的原因

```rust
let s = String::from("你好");
// println!("{}", s[0]); // ❌ 编译错误
```

Rust 禁止直接用数字索引字符串，因为字符串按字节存储，`s[0]` 可能会截断一个 UTF-8 字符，导致非法数据。

安全取法：

```rust
let first_char = s.chars().nth(0);
```

**记忆要点**

* Rust 保护你不写出“半个字符”的错误
* 要按位置取字符，请用 `.chars().nth()`（注意是 O(n)）


## 9. 切片（`&str`）

```rust
let s = String::from("Hello, 世界");
let hello = &s[0..5];  // "Hello"
let world = &s[7..10]; // "世"（UTF-8 边界）
```

如果切片不是在 UTF-8 边界，会 panic：

```rust
// let err = &s[0..2]; // ❌ panic
```

**记忆要点**

* 切片起止位置必须在字符的字节边界上
* 切片是借用，不会复制


## 10. 所有权与函数参数

```rust
fn take_string(s: String) { println!("{}", s); } // 消耗所有权
fn borrow_str(s: &str) { println!("{}", s); }    // 借用

let s = String::from("hello");
borrow_str(&s); // &String 可自动转成 &str
take_string(s);
// println!("{}", s); // ❌ 已被移动
```

**记忆要点**

* 优先用 `&str` 作为参数类型，通用且不会移动数据
* 只有在需要修改或保留字符串所有权时才用 `String`


## 11. `String` 与其他类型转换

```rust
let bytes = String::from("abc").into_bytes(); // String -> Vec<u8>
let s = String::from_utf8(bytes).unwrap();    // Vec<u8> -> String
```

和 C 交互时：

```rust
use std::ffi::CString;
let c_str = CString::new("hello").unwrap();
```

**记忆要点**

* `String` 始终是 UTF-8
* 任意字节数据用 `Vec<u8>`，和 C API 用 `CString`


## 12. 性能优化建议

* 大量拼接前先 `with_capacity()` 预分配
* 在循环里用 `push_str` 或 `write!`，避免频繁 `format!`
* 只在必要时 clone（`clone()` 会复制整个堆数据）

示例：

```rust
use std::fmt::Write;
let mut s = String::with_capacity(100);
for i in 0..10 {
    write!(s, "{},", i).unwrap();
}
```


## 13. 总结速记表

| 操作    | `String`       | `&str`                     |
| ----- | -------------- | -------------------------- |
| 所有权   | 有              | 无                          |
| 存储    | 堆              | 任意（常为静态内存）                 |
| 可变性   | 可变             | 不可变                        |
| 追加/删除 | ✅              | ❌                          |
| 转换    | `&s` 得到 `&str` | `.to_string()` 得到 `String` |

