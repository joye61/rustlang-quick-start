# 集合类型

Rust 的结合类型位于 std::collections 模块，这里只介绍最常用的集合类型：`Vector` / `HashMap` / `HashSet`

## Vector

在 Rust 中，`Vec<T>`（也叫 Vector）是一种**可增长的数组**，可以在运行时动态添加、删除元素。它是最常用的集合类型。

创建 Vector

```rust
fn main() {
    // 创建一个空的 vector，类型为 i32
    let mut v: Vec<i32> = Vec::new();

    // 使用宏创建并初始化
    let v2 = vec![1, 2, 3, 4, 5];

    println!("{:?}", v);   // []
    println!("{:?}", v2);  // [1, 2, 3, 4, 5]
}
```

向 Vector 添加元素

```rust
fn main() {
    let mut v = Vec::new();
    v.push(10);
    v.push(20);
    v.push(30);

    println!("{:?}", v);  // [10, 20, 30]
}
```

> 注意：必须是 `mut` 的 `Vector` 才能改变内容


访问 Vector 元素：

使用索引（可能 panic）

```rust
fn main() {
    let v = vec![1, 2, 3];
    println!("{}", v[1]);  // 2
}
```

如果访问越界会崩溃：

```rust
let v = vec![1, 2, 3];
println!("{}", v[99]); // ❌ 会 panic!
```

使用 `.get()` 方法（安全）

```rust
fn main() {
    let v = vec![1, 2, 3];
    match v.get(2) {
        Some(value) => println!("Found: {}", value),
        None => println!("Not found"),
    }
}
```


遍历 Vector

```rust
fn main() {
    let v = vec![10, 20, 30];

    // 只读遍历
    for val in &v {
        println!("{}", val);
    }

    // 可变引用遍历
    let mut v2 = vec![1, 2, 3];
    for val in &mut v2 {
        *val *= 2;
    }
    println!("{:?}", v2);  // [2, 4, 6]
}
```

删除元素

1、使用 `pop()` 删除最后一个元素：

```rust
fn main() {
    let mut v = vec![1, 2, 3];
    let last = v.pop();
    println!("{:?}, {:?}", v, last);  // [1, 2], Some(3)
}
```

2、使用 `remove(index)` 删除指定位置：

```rust
fn main() {
    let mut v = vec![10, 20, 30];
    v.remove(1);
    println!("{:?}", v);  // [10, 30]
}
```

其他常用方法

| 方法名                   | 功能             |
| ------------------------ | ---------------- |
| `len()`                  | 返回长度         |
| `is_empty()`             | 是否为空         |
| `contains(&value)`       | 是否包含元素     |
| `clear()`                | 清空所有元素     |
| `insert(index, value)`   | 插入元素         |
| `resize(new_len, value)` | 调整长度并填充值 |

示例：

```rust
fn main() {
    let mut v = vec![1, 2, 3];

    println!("长度: {}", v.len()); // 3
    v.insert(1, 99);
    println!("{:?}", v); // [1, 99, 2, 3]

    v.resize(6, 0);
    println!("{:?}", v); // [1, 99, 2, 3, 0, 0]
}
```


Vector 的所有权和借用

```rust
fn main() {
    let v = vec![String::from("hello"), String::from("world")];

    for s in &v {
        println!("{}", s);
    }

    // 所有权没有被移动，可以继续使用 v
    println!("{:?}", v);
}
```


用 Vector 存储不同类型？（不推荐但可行）

Rust 的 `Vec<T>` 必须所有元素类型一样。但可以使用枚举来实现“多类型”效果：

```rust
enum MyValue {
    Int(i32),
    Float(f64),
    Text(String),
}

fn main() {
    let v = vec![
        MyValue::Int(10),
        MyValue::Float(3.14),
        MyValue::Text(String::from("Hello")),
    ];

    for item in v {
        match item {
            MyValue::Int(i) => println!("Int: {}", i),
            MyValue::Float(f) => println!("Float: {}", f),
            MyValue::Text(s) => println!("Text: {}", s),
        }
    }
}
```

小练习：反转一个 Vector

```rust
fn main() {
    let mut v = vec![1, 2, 3, 4, 5];
    v.reverse();
    println!("{:?}", v);  // [5, 4, 3, 2, 1]
}
```


总结

| 内容        | 说明                                   |
| ----------- | -------------------------------------- |
| 创建 Vector | `Vec::new()`，`vec![1,2,3]`            |
| 增加元素    | `.push()`，`.insert()`                 |
| 删除元素    | `.pop()`，`.remove()`                  |
| 访问元素    | `[index]`，`.get()`                    |
| 遍历        | `for val in &v`                        |
| 方法        | `.len()`、`.clear()`、`.contains()` 等 |
| 枚举技巧    | 用于混合类型存储                       |


## HashMap

`HashMap<K, V>` 是一个**键值对集合**，用来**映射关系**（类似 Python 的字典、JavaScript 的对象）。

- 键（Key）必须唯一
- 值（Value）可以重复

创建 HashMap

```rust
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert("apple", 3);
    map.insert("banana", 5);

    println!("{:?}", map);
}
```

访问值

```rust
fn main() {
    let mut scores = HashMap::new();
    scores.insert("math", 90);
    scores.insert("english", 85);

    // 直接索引（可能 panic）
    println!("{}", scores["math"]);

    // 使用 get 方法（推荐）
    if let Some(score) = scores.get("english") {
        println!("English score: {}", score);
    }
}
```


遍历 HashMap

```rust
fn main() {
    let mut map = HashMap::new();
    map.insert("a", 1);
    map.insert("b", 2);

    for (key, value) in &map {
        println!("{}: {}", key, value);
    }
}
```

## 所有权规则

插入 `String` 时，**HashMap 会获取键和值的所有权**。

```rust
fn main() {
    let key = String::from("name");
    let value = String::from("Rust");

    let mut map = HashMap::new();
    map.insert(key, value);

    // key 和 value 不再可用
    // println!("{}", key); ❌ 会报错
}
```

如果你不想转移所有权，可以使用 `.clone()` 或者引用类型。


## 更新 HashMap

覆盖已有键：

```rust
fn main() {
    let mut map = HashMap::new();
    map.insert("a", 1);
    map.insert("a", 2); // 覆盖旧值
    println!("{:?}", map);  // {"a": 2}
}
```

只在不存在时插入：

```rust
fn main() {
    let mut map = HashMap::new();
    map.insert("a", 1);

    map.entry("a").or_insert(100);  // 不会插入
    map.entry("b").or_insert(200);  // 会插入

    println!("{:?}", map);  // {"a": 1, "b": 200}
}
```

修改已有值：

```rust
fn main() {
    let mut map = HashMap::new();
    map.insert("count", 1);

    if let Some(x) = map.get_mut("count") {
        *x += 1;
    }

    println!("{:?}", map);  // {"count": 2}
}
```

删除元素

```rust
fn main() {
    let mut map = HashMap::new();
    map.insert("key1", 10);
    map.remove("key1");

    println!("{:?}", map);  // {}
}
```


常用方法汇总

| 方法名                    | 功能                    |
| ------------------------- | ----------------------- |
| `.insert(k, v)`           | 插入或覆盖键值          |
| `.get(k)`                 | 获取值（返回 `Option`） |
| `.remove(k)`              | 删除键值对              |
| `.contains_key(k)`        | 是否包含键              |
| `.entry(k).or_insert(v)`  | 插入默认值              |
| `.keys()` / `.values()`   | 所有键 / 所有值         |
| `.iter()` / `.iter_mut()` | 遍历键值对              |


## HashSet

`HashSet<T>` 是一个集合，**只存值，且不重复**。它背后其实就是 `HashMap<T, ()>`。

适合用于：

- 去重
- 判断集合关系
- 集合运算（并交差）

创建 HashSet

```rust
use std::collections::HashSet;

fn main() {
    let mut set = HashSet::new();
    set.insert("apple");
    set.insert("banana");
    set.insert("apple");  // 重复，不会插入

    println!("{:?}", set);  // {"apple", "banana"}
}
```

判断是否包含元素

```rust
fn main() {
    let mut set = HashSet::new();
    set.insert("rust");

    println!("{}", set.contains("rust"));  // true
    println!("{}", set.contains("go"));    // false
}
```


删除元素

```rust
fn main() {
    let mut set = HashSet::new();
    set.insert("c++");
    set.remove("c++");

    println!("{:?}", set);  // {}
}
```

遍历 HashSet

```rust
fn main() {
    let mut set = HashSet::new();
    set.insert("a");
    set.insert("b");

    for val in &set {
        println!("{}", val);
    }
}
```

集合运算（交集/并集/差集）

```rust
fn main() {
    let set1: HashSet<_> = [1, 2, 3].into_iter().collect();
    let set2: HashSet<_> = [2, 3, 4].into_iter().collect();

    // 并集
    println!("Union: {:?}", set1.union(&set2).collect::<Vec<_>>());

    // 交集
    println!("Intersection: {:?}", set1.intersection(&set2).collect::<Vec<_>>());

    // 差集
    println!("Difference: {:?}", set1.difference(&set2).collect::<Vec<_>>());
}
```

## 总结对比

| 集合类型        | 特点         | 用途               |
| --------------- | ------------ | ------------------ |
| `Vec<T>`        | 可变长度数组 | 有序集合，允许重复 |
| `HashMap<K, V>` | 键值对映射   | 表结构，快速查找   |
| `HashSet<T>`    | 无重复的值   | 去重、集合运算     |
