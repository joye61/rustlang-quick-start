# Rust — 元组（Tuple）详解（通俗版 + 例子）

把元组当作“**定长、可存放不同类型**的打包值”。它的长度和每个元素的类型在**编译期确定**。

---

## 1) 基本语法与类型

```rust
fn main() {
    let t1 = (1, 3.14, "hi");              // 类型：(i32, f64, &str)
    let t2: (u8, bool) = (7, true);        // 显式标注

    // 单元素元组：必须带逗号！
    let one = (5,);                         // 类型：(i32,)
    let not_tuple = (5);                    // 只是 i32，而不是元组

    // 空元组：()
    let unit = ();                          // 类型：()（单位类型 / unit type）
}
```

* `()` 被称为 **unit**，表示“没有有意义的值”。函数不返回值时，返回的就是 `()`。
* 元组与数组不同：数组是**同类型多元素**，元组是**不同类型定长组合**。

---

## 2) 访问元素：解构与索引

### 解构绑定（推荐，可读性最好）

```rust
fn main() {
    let user = ("Alice", 20, true);
    let (name, age, is_vip) = user;
    println!("{name} - {age} - {is_vip}");
}
```

### 点号数字索引（编译期常量）

```rust
fn main() {
    let t = ("rgb", 255, 128, 64);
    println!("{}", t.0);   // "rgb"
    println!("{}", t.1);   // 255
    // t[0]; // ❌ 不支持方括号索引
}
```

> 注意：元组**不支持**运行时动态索引（如 `t[i]`），只能用 `.0/.1/...` 或解构。

---

## 3) 打印与调试

* 元组没有实现 `Display`（`{}`），但实现了 `Debug`（`{:?}`）。

```rust
fn main() {
    let t = (1, "x", 2.5);
    println!("{:?}", t);    // (1, "x", 2.5)
    println!("{:#?}", t);   // 漂亮打印（多行缩进）
}
```

---

## 4) 模式匹配（match/let）与忽略

```rust
fn main() {
    let event = ("click", 120, 300);

    match event {
        ("click", x, y) => println!("click at ({x}, {y})"),
        ("scroll", amount, _) => println!("scroll {amount}"), // 忽略用 _
        _ => println!("other"),
    }

    // 忽略部分绑定
    let (x, _, z) = (10, 20, 30);
    println!("{x} {z}");

    // 嵌套解构
    let nested = (("id", 42), true);
    let ((_, id), ok) = nested;
    println!("{id}, ok={ok}");
}
```

---

## 5) 作为函数参数与返回值（返回多个值的常用手段）

```rust
fn div_rem(a: i32, b: i32) -> (i32, i32) {
    (a / b, a % b)
}

fn main() {
    let (q, r) = div_rem(10, 3);
    println!("q={q}, r={r}");
}
```

> 习惯做法：函数需要返回多项数据时，优先考虑元组；数据含义需要**命名**且会频繁使用时，考虑 `struct`。

---

## 6) 可变性与解构赋值（就地交换等）

```rust
fn main() {
    let mut a = 1;
    let mut b = 2;

    // 解构赋值（稳定特性）：就地交换
    (a, b) = (b, a);
    println!("{a} {b}");

    // 也可用标准函数
    // std::mem::swap(&mut a, &mut b);
}
```

> 解构赋值不引入新变量；而 `let (a, b) = (b, a);` 是**重新绑定/遮蔽**旧变量。

---

## 7) 引用解构（`ref` / `ref mut`）

```rust
fn main() {
    let mut t = (String::from("hi"), 99);

    // 把元素以引用的方式解构出来
    let (ref s_ref, ref mut n_ref) = t;
    println!("len = {}", s_ref.len());
    *n_ref += 1;

    println!("{:?}", t); // ("hi", 100)
}
```

---

## 8) 与结构体的对比：元组结构体（Tuple Struct）

```rust
struct Color(u8, u8, u8);      // 元组结构体
struct Point { x: i32, y: i32 } // 具名字段结构体

fn main() {
    let c = Color(255, 128, 64);
    println!("r={}, g={}, b={}", c.0, c.1, c.2); // 通过 .0/.1/.2 访问
}
```

* **元组结构体**：字段**没有名字**，用序号访问，适合“位置含义明确且简单”的场景（如坐标、RGB）。
* **具名结构体**：字段有名字，可读性更强，适合复杂数据。

---

## 9) 与数组/切片的区别

| 特性   | 元组 `(T1, T2, ...)` | 数组 `[T; N]` / 切片 `[T]` |
| ---- | ------------------ | ---------------------- |
| 元素类型 | 可不同                | 必须相同                   |
| 长度   | 编译期固定              | 编译期固定（数组），运行期不定（切片）    |
| 访问   | `.0/.1` 或解构        | `a[i]`                 |
| 迭代   | 不能直接迭代             | 可迭代                    |
| 典型用途 | 多返回值、小范围打包         | 批量同类数据                 |

> 想“遍历”多个不同类型的值？用 match/解构拆开它，而不是迭代。

---

## 10) 常用 trait 与比较规则（“词典序”）

标准库为**最多 12 个元素**的元组提供了许多 trait 实现（前提：每个元素也实现了对应 trait），例如：

* `Debug`、`Clone`、`Copy`、`Default`
* `PartialEq` / `Eq`（相等比较）
* `PartialOrd` / `Ord`（大小比较，**按字典序**：先比第 0 个，相等再比第 1 个……）
* `Hash`

示例（比较与排序）：

```rust
fn main() {
    let mut v = vec![(1, "b"), (1, "a"), (0, "z")];
    v.sort(); // 先按第0个排，再按第1个排
    println!("{:?}", v); // [(0, "z"), (1, "a"), (1, "b")]
}
```

---

## 11) 格式化细节与小坑

* 打印要用 `{:?}`/`{:#?}`（Debug），**不能**用 `{}`（Display）。
* 单元素元组必须写尾逗号：`(x,)`；否则只是 `x` 的括号分组。
* 不能使用 `[]` 访问：`t[0]` ❌；请用 `.0` 或解构。
* 元组不是集合结构，**不要**指望它支持“长度/迭代/推入”等操作。
* 元组类型是**类型的一部分**：`(i32, i32)` 与 `(i32, u8)` 是不同类型，函数签名要精确匹配。

---

## 12) 实战小抄（把常见用法攒一起）

```rust
fn point() -> (i32, i32) {
    (3, 4)
}

fn main() {
    // 创建 & 打印
    let t = ("id", 42, true);
    println!("{:?}", t);

    // 解构
    let (tag, num, flag) = t;
    println!("{tag} {num} {flag}");

    // 访问字段
    println!("tag={}, num={}, flag={}", t.0, t.1, t.2);

    // 单元素/空元组
    let _one = (7,);
    let _unit: () = ();

    // 返回多个值
    let (x, y) = point();

    // 交换
    let (mut a, mut b) = (1, 2);
    (a, b) = (b, a);

    // 模式匹配
    match ("move", x, y) {
        ("move", 0, y) => println!("on y={y} axis"),
        ("move", x, 0) => println!("on x={x} axis"),
        _ => {}
    }
}
```

---

### 一句话总结

* 元组：**定长 + 可异构**，适合“临时打包/多返回值/轻量数据”。
* 访问用**解构**或 `.0/.1/...`；打印用 `{:?}`。
* 比较与排序按**字典序**；需要可读性或稳定结构时，用 `struct` 更好。

如果你愿意，我可以再补一节“**什么时候用元组、什么时候用结构体**”的决策清单，或帮你把上面的示例打包成一份可打印的 Markdown 笔记。
