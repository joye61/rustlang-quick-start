# Rust 里有哪些测试？

* **单元测试（unit tests）**：和代码放一起，测**小而精**的函数/模块。
* **集成测试（integration tests）**：放 `tests/` 目录，**从使用者角度**测公开 API。
* **文档测试（doc tests）**：写在文档注释里的示例会被**编译并运行**，防止文档“说谎”。

运行命令都一样：

```bash
cargo test
```


## 3 分钟上手：最小可运行例子

`src/lib.rs`

```rust
pub fn add(a: i32, b: i32) -> i32 { a + b }

#[cfg(test)]
mod tests {
    use super::*; // 把父模块里的符号引进来

    #[test]
    fn add_works() {
        assert_eq!(add(2, 3), 5);
    }
}
```

运行：

```bash
cargo test
```

解释：

* `#[cfg(test)]`：只在测试构建时编译这些代码。
* `#[test]`：告诉测试框架“这是一个测试函数”。
* `assert_eq!`：断言相等，失败会显示左/右值。


## 断言家族与错误期望

常用断言：

```rust
assert!(cond);              // 条件为真
assert_eq!(left, right);    // 左右相等（需要实现 Debug）
assert_ne!(left, right);    // 左右不等
```

匹配模式（很香）：

```rust
let x: Result<i32, &str> = Ok(42);
assert!(matches!(x, Ok(v) if v > 0));
```

浮点比较（避免直接 `==`）：

```rust
let x = 0.1f64 + 0.2;
let y = 0.3;
assert!((x - y).abs() < 1e-12);
```

测试应当**失败（panic）**：

```rust
#[test]
#[should_panic]                  // 只要 panic 就算通过
fn must_panic() { panic!("boom"); }

#[test]
#[should_panic(expected = "boom")] // 信息需包含 "boom"
fn must_panic_with_message() { panic!("boom!!!"); }
```

用 `Result` 表达可失败测试（更灵活）：

```rust
#[test]
fn fallible_test() -> Result<(), String> {
    if 1 + 1 == 2 { Ok(()) } else { Err("math broken".into()) }
}
```


## 组织单元测试：文件内的 `mod tests`

典型写法（支持**测试私有函数**）：

```rust
pub(crate) fn private_helper(x: i32) -> i32 { x + 1 }

#[cfg(test)]
mod tests {
    use super::*;

    fn setup() -> i32 { 40 } // “伪 fixture”：每个用例自己调用

    #[test]
    fn helper_plus_one() {
        let base = setup();
        assert_eq!(private_helper(base), 41);
    }
}
```

> Rust 没有 JUnit 那样的全局 `setup/teardown`，通常用**普通函数**充当“夹具（fixture）”。


# 集成测试：从外部像用户一样测

结构：

```
mycrate/
├─ src/lib.rs
└─ tests/
   ├─ api_basic.rs
   └─ edge_cases.rs
```

`src/lib.rs`

```rust
pub fn mul(a: i32, b: i32) -> i32 { a * b }
```

`tests/api_basic.rs`

```rust
use mycrate::mul; // 注意：像外部使用者一样引入

#[test]
fn mul_works() {
    assert_eq!(mul(6, 7), 42);
}
```

> 每个 `tests/*.rs` 都是**单独的可执行 crate**。
> 只能访问 `pub` API（这正是我们想要的“黑盒”视角）。

**二进制项目也要测？**

把核心逻辑放到 `src/lib.rs`（库 crate），`src/main.rs` 只写启动/解析参数，然后用上面的办法测库里的逻辑。


# 文档测试（doc tests）：示例能跑就不骗人

`src/lib.rs`

````rust
/// 计算 a+b。
///
/// # Examples
/// ```
/// use mycrate::add;
/// assert_eq!(add(2, 3), 5);
/// ```
///
/// 隐藏准备代码（不会出现在文档里，但会编译执行）：
/// ```
/// # fn hidden() {}
/// # hidden();
/// ```
pub fn add(a: i32, b: i32) -> i32 { a + b }
````

运行：

```bash
cargo test --doc   # 只跑文档测试
cargo test         # 默认也会包含 doc tests
```

> 小技巧：示例里以 `# ` 开头的行是**隐藏**的准备代码。


# 异步测试

Rust 本身没有内置运行时；用你选的运行时的测试宏即可。

以 Tokio 为例（`Cargo.toml` 添加 `tokio`，启用 `macros`）：

```rust
// Cargo.toml
// tokio = { version = "1", features = ["macros", "rt-multi-thread", "time"] }

#[tokio::test]
async fn async_works() {
    use tokio::time::{sleep, Duration};
    sleep(Duration::from_millis(10)).await;
    assert!(true);
}
```

> async-std 也有 `#[async_std::test]`，思路一样。


# 参数化 / 表驱动测试（Rust 原生没有参数化宏）

直接**表驱动**最简单：

```rust
#[test]
fn table_driven() {
    let cases = [
        (2, 3, 5),
        (0, 0, 0),
        (-1, 1, 0),
    ];
    for (a, b, want) in cases {
        assert_eq!(crate::add(a, b), want, "case: {a}+{b}");
    }
}
```


# Mock / Fake：没有标准库 Mock，推荐“面向接口编程”

定义 trait，把依赖注入进来；测试时传入假实现（Fake）：

```rust
pub trait Clock { fn now(&self) -> u64; }

pub struct SysClock;
impl Clock for SysClock {
    fn now(&self) -> u64 { 1234567890 } // 例子
}

pub fn greet<C: Clock>(clk: &C) -> String {
    format!("ts={}", clk.now())
}

#[cfg(test)]
mod tests {
    use super::*;

    struct FakeClock(u64);
    impl Clock for FakeClock { fn now(&self) -> u64 { self.0 } }

    #[test]
    fn greet_deterministic() {
        let fake = FakeClock(42);
        assert_eq!(greet(&fake), "ts=42");
    }
}
```

> 这样避免时间/网络/随机数等**不确定因素**；更快更稳。


# I/O 与临时文件

不引入第三方也能用系统临时目录：

```rust
use std::{fs, env, path::PathBuf};

fn write_tmp(content: &str) -> PathBuf {
    let mut p = env::temp_dir();
    p.push("mycrate_test.txt");
    fs::write(&p, content).unwrap();
    p
}

#[test]
fn write_and_read() {
    let p = write_tmp("hello");
    let s = fs::read_to_string(p).unwrap();
    assert_eq!(s, "hello");
}
```

> 更推荐用第三方 `tempfile`（自动清理），思路相同。


# 运行技巧（过滤/并发/输出）

* 只跑名字里含 `mul` 的测试：

  ```bash
  cargo test mul
  ```
* 查看 `println!` 输出（默认被捕获）：

  ```bash
  cargo test -- --nocapture
  ```
* 控制并发（默认多线程并行）：

  ```bash
  cargo test -- --test-threads=1
  ```
* 标记慢测例并默认跳过：

  ```rust
  #[test]
  #[ignore]
  fn long_running() { /* ... */ }
  ```

  只跑被忽略的用例：

  ```bash
  cargo test -- --ignored
  ```


# 文档结构推荐（库 + 可执行）

```
src/
 ├─ lib.rs        // 业务核心 + 单元测试
 ├─ main.rs       // 程序入口（可选）
tests/            // 黑盒集成测试
 ├─ api_basic.rs
 └─ edge_cases.rs
```

# 小抄（Cheat Sheet）

* 写单元测试：`#[cfg(test)] mod tests { use super::*; #[test] fn t(){...} }`
* 常用断言：`assert! / assert_eq! / assert_ne! / matches!`
* 期望失败：`#[should_panic]` / `#[should_panic(expected="...")]`
* 只跑某些：`cargo test name_substring`
* 看输出：`cargo test -- --nocapture`
* 串行运行：`cargo test -- --test-threads=1`
* 异步测试：`#[tokio::test] async fn ...`
* 集成测试：`tests/*.rs`，像用户一样 `use mycrate::...`
* 文档测试：\`/// \`\`\`rust ... \`\`\`\`


## `#[cfg(test)]` 是干什么的？

这是 **条件编译宏**，意思是：

> 当你运行 `cargo test` 时，编译器才会编译带有 `#[cfg(test)]` 的代码块。
> 当你运行 `cargo build` 或 `cargo run` 时，这些测试代码不会被编译进最终程序。

它一般写在 **源码文件里**，比如 `src/lib.rs` 或 `src/xxx.rs`，用来包裹单元测试代码。

示例：

```rust
// src/lib.rs
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]  // 只有测试时才编译这里
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }
}
```


## 单元测试（unit test）

* 单元测试通常就写在 `#[cfg(test)] mod tests` 里面。
* **位置**：跟被测试的代码放在同一个文件，或者同一个 crate 下的 `src/` 里。
* **目的**：测试某个函数、某个模块的内部逻辑。
* **关键点**：

  * `#[cfg(test)]`：让测试代码只在测试时编译。
  * `#[test]`：标记具体的测试函数。


## 集成测试（integration test）

* **位置**：必须放在项目根目录的 `tests/` 文件夹下（和 `src/` 同级）。
* **目的**：测试 crate 的 **公共接口**（相当于外部用户用你的库）。
* **写法**：

  * 直接在 `tests/xxx.rs` 里面写 `#[test]` 函数。
  * 不需要 `#[cfg(test)]`，因为整个 `tests/` 文件夹就是测试用的，只有 `cargo test` 会编译它。

示例：

```
my_crate/
 ├── Cargo.toml
 ├── src/
 │   └── lib.rs
 └── tests/
     ├── integration_test.rs
```

```rust
// tests/integration_test.rs
use my_crate;  // 当作外部库一样引入

#[test]
fn test_add() {
    assert_eq!(my_crate::add(1, 2), 3);
}
```

---

## 名字是不是“约定死的”？

### `#[cfg(test)]`

* 这是 **固定写法**，不能改名字。
* 因为它是编译条件的一个配置项，Rust 编译器只认 `test` 这个值。

### `#[test]`

* 这是 **固定写法**，必须写 `#[test]`，才能让 Cargo 测试框架识别。
* 如果换别的名字，比如 `#[testing]`，编译器根本不认。

### `tests/` 目录

* 这是 Cargo 约定俗成的目录名。
* 如果你写成 `integration_tests/`，Cargo 默认不会去编译它。
* 当然，你可以自己写 `[[test]]` 配置到 `Cargo.toml`，手动指定别的路径，但标准做法就是用 `tests/`，否则容易让别人读不懂项目。

**总结一下：**

1. `#[cfg(test)]` 只能写在源码里的测试模块中，固定名字，不能改。
2. `#[test]` 宏是固定写法，不能改名字。
3. `tests/` 目录是 Cargo 的默认约定，你最好照着用；虽然理论上可以改，但不推荐。
