# 类型转换、Newtype 和类型别名

## 类型转换（Type Conversion）

Rust 默认不进行**隐式类型转换（implicit coercion）**，不像 C/C++ 可以自动把 `int` 转成 `float`，Rust 一切都必须**显式转换**。

### 数值类型之间的转换

使用 `as` 关键字

```rust
fn main() {
    let x: u32 = 10;
    let y: f64 = x as f64;
    println!("y = {}", y); // y = 10.0
}
```

`as` 会**强制转换**，但请小心精度损失或溢出。

```rust
fn main() {
    let a: i32 = -1;
    let b: u32 = a as u32; // b = 4294967295
    println!("b = {}", b);
}
```

### 字符和数字之间的转换

```rust
fn main() {
    let c = 'A';
    let code = c as u8;
    println!("ASCII: {}", code); // ASCII: 65
}
```

```rust
fn main() {
    let code = 66;
    let c = char::from_u32(code).unwrap();
    println!("Char: {}", c); // Char: B
}
```

### 使用 `TryFrom` 和 `TryInto`

对于可能失败的转换（比如负数转无符号），应使用 `std::convert::TryFrom`。

```rust
use std::convert::TryFrom;

fn main() {
    let n: i16 = -10;
    let result = u16::try_from(n);
    match result {
        Ok(v) => println!("v = {}", v),
        Err(e) => println!("Error: {}", e),
    }
}
```

### 自定义类型转换：`From` 和 `Into`

实现 `From`

```rust
struct MyNumber(i32);

impl From<i32> for MyNumber {
    fn from(num: i32) -> Self {
        MyNumber(num)
    }
}

fn main() {
    let my_num = MyNumber::from(100);
}
```

自动衍生 `Into`

只要实现了 `From<T> for U`，就可以自动使用 `Into<U> for T`

```rust
fn main() {
    let n: MyNumber = 200.into(); // 自动转换
}
```

### 使用 `as` vs `From/Into`

| 场景     | 推荐用法        | 是否安全  |
| ------ | ----------- | ----- |
| 基础类型强转 | `as`        | 不一定安全 |
| 自定义类型  | `From/Into` | 安全    |
| 可能失败   | `TryFrom`   | 安全    |

---

## Newtype 模式（Newtype Pattern）

Newtype 是一种为现有类型创建“包裹”的新类型，以添加语义或实现 Trait

什么是 Newtype？

```rust
struct Meters(u32); // 包裹了一个 u32

fn main() {
    let distance = Meters(100);
}
```

相比直接使用 `u32`，`Meters` 更具语义，也避免了类型混淆：

```rust
struct Seconds(u32);

fn run(distance: Meters, time: Seconds) {
    println!("Speed: {} m/s", distance.0 / time.0);
}
```

为什么使用 Newtype？

* 增加语义（单位、作用明确）
* 防止类型误用
* 可以为其单独实现 Trait（比如 `Display`, `Add` 等）

```rust
use std::fmt;

struct UserId(u64);

impl fmt::Display for UserId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "#{}", self.0)
    }
}
```

访问内部值

```rust
let id = UserId(42);
println!("id = {}", id.0);
```

你也可以实现一个方法来封装访问逻辑：

```rust
impl UserId {
    fn value(&self) -> u64 {
        self.0
    }
}
```

与元组类型的区别？

```rust
struct Newtype(u32);    // 定义了一个新类型
type Alias = (u32);     // 只是别名，不是新类型
```


## 类型别名（Type Alias）

类型别名用 `type` 关键字为已有类型起一个新名字，不创建新类型。

基本用法:

```rust
type Kilometers = i32;

fn distance(d: Kilometers) {
    println!("Distance = {}", d);
}
```

本质上，`Kilometers` 还是 `i32`，不能用于类型区分。

用于简化复杂类型

```rust
use std::collections::HashMap;

type Name = String;
type Scores = HashMap<Name, Vec<u32>>;

fn main() {
    let mut scores: Scores = HashMap::new();
}
```

与 Newtype 的区别

| 特性       | 类型别名（Alias） | Newtype   |
| -------- | ----------- | --------- |
| 是否创建新类型  | ❌ 否         | ✅ 是       |
| 类型安全     | ❌ 无         | ✅ 有       |
| Trait 实现 | 共享原始类型      | 可单独实现     |
| 用途       | 简化代码、可读性    | 增强语义、类型隔离 |


# `From`、`Into`、`TryFrom`、`TryInto`

Rust 是强类型语言，不允许隐式类型转换。但它提供了四个 Trait，帮助你在类型之间**安全、清晰、可控**地进行转换：

| Trait        | 是否可能失败  | 常用于什么场景    |
| ------------ | ------- | ---------- |
| `From<T>`    | ✅ 永不失败  | 明确能安全转换    |
| `Into<T>`    | ✅ 永不失败  | 适配性强，配合泛型  |
| `TryFrom<T>` | ⚠️ 可能失败 | 类型不一定能安全转换 |
| `TryInto<T>` | ⚠️ 可能失败 | 同上，适用于泛型函数 |


## `From<T>`

定义：

`From<T>` 表示可以从类型 `T` **转换为 Self 类型**，而且这个转换**永远不会失败**。

```rust
pub trait From<T> {
    fn from(value: T) -> Self;
}
```

示例 1：基本类型转换

```rust
fn main() {
    let s = String::from("hello"); // 从 &str 转换成 String
}
```

Rust 标准库为常见类型实现了 `From`，比如：

```rust
impl From<&str> for String
```

示例 2：自定义结构体转换

```rust
struct MyInt(i32);

impl From<i32> for MyInt {
    fn from(num: i32) -> Self {
        MyInt(num)
    }
}

fn main() {
    let a = MyInt::from(5);
    println!("a = {}", a.0); // 输出: 5
}
```


## `Into<T>`

定义：

`Into<T>` 表示可以**转换为类型 T**，前提是 `T` 实现了 `From<Self>`。

```rust
pub trait Into<T> {
    fn into(self) -> T;
}
```

你**通常不用自己实现 `Into`** —— Rust 会自动从 `From` 推导出 `Into`。

示例：

```rust
struct MyInt(i32);

impl From<i32> for MyInt {
    fn from(n: i32) -> Self {
        MyInt(n)
    }
}

fn main() {
    let num: MyInt = 42.into(); // 自动推导成 MyInt::from(42)
}
```

用法对比：

```rust
let a = MyInt::from(10);   // 调用 from
let b: MyInt = 10.into();  // 调用 into，自动使用 from
```

用于泛型函数

```rust
fn print_number<T: Into<i32>>(value: T) {
    let num: i32 = value.into();
    println!("Number: {}", num);
}

fn main() {
    print_number(100); // i32 自动转换
}
```

## `TryFrom`（可能失败的转换）

定义：

当转换**可能失败**时，使用 `TryFrom`。

```rust
pub trait TryFrom<T>: Sized {
    type Error;
    fn try_from(value: T) -> Result<Self, Self::Error>;
}
```

示例：

```rust
use std::convert::TryFrom;

fn main() {
    let value: i8 = 100;
    let result = u8::try_from(value); // i8 → u8，可能失败

    match result {
        Ok(v) => println!("Success: {}", v),
        Err(e) => println!("Failed: {}", e),
    }
}
```

自定义实现 `TryFrom`

```rust
use std::convert::TryFrom;

struct Positive(i32);

impl TryFrom<i32> for Positive {
    type Error = &'static str;

    fn try_from(value: i32) -> Result<Self, Self::Error> {
        if value >= 0 {
            Ok(Positive(value))
        } else {
            Err("Must be non-negative")
        }
    }
}

fn main() {
    let pos = Positive::try_from(10); // ✅ Ok
    let neg = Positive::try_from(-5); // ❌ Err

    println!("{:?}", pos); // Ok(Positive(10))
    println!("{:?}", neg); // Err("Must be non-negative")
}
```

## `TryInto`

与 `Into` 类似，`TryInto` 是 `TryFrom` 的泛型补充，用于“转换到目标类型”，同样是可能失败。

```rust
pub trait TryInto<T>: Sized {
    type Error;
    fn try_into(self) -> Result<T, Self::Error>;
}
```

只要实现了 `TryFrom<T> for U`，就能自动使用 `TryInto<U> for T`。

示例：

```rust
use std::convert::TryInto;

fn main() {
    let x: i32 = -10;
    let y: Result<u32, _> = x.try_into(); // 自动调用 TryFrom

    match y {
        Ok(n) => println!("Converted: {}", n),
        Err(e) => println!("Failed: {}", e),
    }
}
```


##  对比

| Trait        | 会不会失败  | 通常由谁实现  | 调用方式               | 用于泛型函数 |
| ------------ | ------ | ------- | ------------------ | ------ |
| `From<T>`    | ❌ 永不失败 | 目标类型    | `T::from(val)`     | 否      |
| `Into<T>`    | ❌ 永不失败 | 源类型（推导） | `val.into()`       | ✅ 是    |
| `TryFrom<T>` | ✅ 可能失败 | 目标类型    | `T::try_from(val)` | 否      |
| `TryInto<T>` | ✅ 可能失败 | 源类型（推导） | `val.try_into()`   | ✅ 是    |


## 注意事项

* 想用 `.into()`，就实现 `From`
* 想用 `.try_into()`，就实现 `TryFrom`
* 避免为同一类型间写多个 `From` 实现（可能冲突）
* `Into`/`TryInto` 适合泛型 API，比如函数参数接受多种类型
* `?` 运算符可以与 `TryFrom` 搭配返回错误

## 总结

| 想做的事                  | 应该用哪个 Trait           |
| --------------------- | --------------------- |
| 100% 安全的转换            | `From` / `Into`       |
| 可能失败的转换               | `TryFrom` / `TryInto` |
| 提供语义明确的转换实现           | `From` / `TryFrom`    |
| 写泛型函数调用 `.into()`     | 只需实现 `From`           |
| 写泛型函数调用 `.try_into()` | 只需实现 `TryFrom`        |

