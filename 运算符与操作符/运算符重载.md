# Rust 运算符重载：

Rust 中的“运算符重载”并不是自己实现新的语法，而是实现标准库里对应的 trait（`std::ops`、`std::cmp` 等），写这些 trait 的 `impl` 就能让自定义类型使用相应的运算符。

比如 `+` 对应的 trait 是 `std::ops::Add`，`==` 对应的 trait 是 `PartialEq`，`[]` 对应的 trait 是 `Index` 等等


## 为什么需要运算符重载？

让自定义类型（如 `Point`）也能像 `i32` 一样使用 `+`、`-` 等运算符，代码更直观：

```rust
let p1 = Point {x: 1, y: 2};
let p2 = Point {x: 3, y: 4};
let p3 = p1 + p2; // 希望得到 Point {x:4, y:6}
```

## 核心机制：Trait 驱动

Rust 将运算符绑定到 `std::ops`, `std::cmp` 等模块中的 **Trait**。重载等于为你的类型实现对应 Trait！

重载步骤（万能公式）：

1. **选 Trait**：根据运算符查对应 Trait
2. **实现 Trait**：在 `impl` 块中定义运算逻辑
3. **指定 Output**：声明运算结果类型（关键！）

示例：

重载 `+` 运算符，让 `Point` 结构体支持 `+`

```rust
// 1. 导入 Trait
use std::ops::Add; 

#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

// 2. 实现 Add Trait
impl Add for Point {
    // 3. 指定结果类型（必须！）
    type Output = Point; 

    // 定义 + 的行为：x 和 y 分别相加
    fn add(self, other: Point) -> Self::Output {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    let p1 = Point {x: 1, y: 2};
    let p2 = Point {x: 3, y: 4};
    let p3 = p1 + p2; // 自动调用 add 方法
    println!("{:?}", p3); // 输出: Point { x: 4, y: 6 }
}
```

关键细节：

- **`type Output` 必须声明**：告诉编译器 `+` 的结果是什么类型（可以是其他类型，如 `Point + i32`）
- **参数所有权**：默认消耗 `self`（值传递），如需保留原值改用 `&self`（见下文扩展）

---

## 常见运算符重载

| 运算符 | Trait       | 方法签名                               | 适用场景                    |
| ------ | ----------- | -------------------------------------- | --------------------------- |
| `+`    | `Add`       | `fn add(self, rhs) -> Self::Output`    | 二元加法                    |
| `-`    | `Sub`       | `fn sub(self, rhs) -> Self::Output`    | 二元减法                    |
| `*`    | `Mul`       | `fn mul(self, rhs) -> Self::Output`    | 乘法                        |
| `/`    | `Div`       | `fn div(self, rhs) -> Self::Output`    | 除法                        |
| `%`    | `Rem`       | `fn rem(self, rhs) -> Self::Output`    | 取模                        |
| `-`    | `Neg`       | `fn neg(self) -> Self::Output`         | **一元负号**（如 `-point`） |
| `!`    | `Not`       | `fn not(self) -> Self::Output`         | 逻辑非                      |
| `&`    | `BitAnd`    | `fn bitand(self, rhs) -> Self::Output` | 位与                        |
| `+=`   | `AddAssign` | `fn add_assign(&mut self, rhs)`        | **赋值运算符**（关键！）    |

> 完整列表参考: [重载Trait列表](./重载Trait列表.md)

## 重要扩展：

1. **引用重载（保留原值）**  
   默认 `add(self)` 会消耗原值，如需保留：

   ```rust
   impl Add for &Point { // 用引用实现，请注意 &Point 用法
       type Output = Point;
       fn add(self, other: &Point) -> Point {
           Point { x: self.x + other.x, y: self.y + other.y }
       }
   }
   // 使用：p1 + p2 依然有效（自动解引用）
   ```

2. **重载赋值运算符（如 `+=`）**  
   需实现 `*Assign` Trait（参数必须是 `&mut self`）：

   ```rust
   use std::ops::AddAssign;

   impl AddAssign for Point {
       fn add_assign(&mut self, other: Point) {
           self.x += other.x;
           self.y += other.y;
       }
   }

   fn main() {
       let mut p = Point {x:1, y:2};
       p += Point {x:3, y:4}; // ✅ 修改 p 自身
   }
   ```

3. **混合类型运算（如 `Point + i32`）**  
   通过 `Rhs` 泛型指定右侧类型：

   ```rust
   impl Add<i32> for Point { // Point + i32
       type Output = Point;
       fn add(self, rhs: i32) -> Point {
           Point { x: self.x + rhs, y: self.y + rhs }
       }
   }
   ```

4. **比较运算符重载**  
   通过 `PartialEq` / `PartialOrd` 实现 `==`、`<` 等：

   ```rust
   use std::cmp::PartialEq;

   impl PartialEq for Point {
       fn eq(&self, other: &Self) -> bool {
           self.x == other.x && self.y == other.y
       }
   }
   // 现在可以写 p1 == p2
   ```

## 必须知道的注意事项

1. **不能重载的运算符**  
   `&&`、`||`（短路求值）、`=`（赋值）、`..`（范围）**无法重载**，这是 Rust 的安全设计。

2. **Output 类型必须匹配**  
   如果 `Add` 的 `Output` 不是 `Point`，则 `p1 + p2` 会返回其他类型（如 `f32`）：

   ```rust
   impl Add for Point {
       type Output = f32;
       fn add(self, other: Point) -> f32 {
           ((self.x - other.x).pow(2) + (self.y - other.y).pow(2)) as f32
       }
   }
   // p1 + p2 返回两点间距离（浮点数）
   ```

3. **保持语义合理**  
   Rust 社区原则：**重载应符合直觉**。  
   ✅ 好：`Vector + Vector` = 向量加法  
   ❌ 坏：`String + String` = 拼接（Rust 用 `+` 实现拼接是特例，非常规做法）

4. **Trait 必须导入**  
   每次重载前记得：`use std::ops::{Add, Sub, ...};`


一句话总结

> **Rust 运算符重载等于为你的类型实现 `std::ops`，`std::cmp` 中的 Trait**


完整实践：从零重载 `+` 和 `+=`

```rust
use std::ops::{Add, AddAssign};

#[derive(Debug)]
struct Vector(i32, i32);

// 重载 + (返回新对象)
impl Add for Vector {
    type Output = Vector;
    fn add(self, rhs: Vector) -> Vector {
        Vector(self.0 + rhs.0, self.1 + rhs.1)
    }
}

// 重载 += (修改自身)
impl AddAssign for Vector {
    fn add_assign(&mut self, rhs: Vector) {
        self.0 += rhs.0;
        self.1 += rhs.1;
    }
}

fn main() {
    let v1 = Vector(1, 2);
    let v2 = Vector(3, 4);

    // 使用 +
    let v3 = v1 + v2;
    println!("{:?}", v3); // Vector(4, 6)

    // 使用 +=
    let mut v4 = Vector(5, 6);
    v4 += Vector(1, 1);
    println!("{:?}", v4); // Vector(6, 7)
}
```
