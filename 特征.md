# Trait（特征）

> Trait 是 Rust 的一个核心概念，类似其他语言的“接口”或“类型类”。它定义了一组可以被实现的**行为规范**。

---

## 🔹 什么是 Trait？

Trait 就是一个行为“约定”，谁实现了它，谁就具备了这套功能。

例如，我们可以定义一个可以“叫”的 Trait：

```rust
trait Speak {
    fn speak(&self);
}
```

### 谁来实现？

```rust
struct Dog;

impl Speak for Dog {
    fn speak(&self) {
        println!("汪汪！");
    }
}
```

---

## 🛠 基本语法

### 定义 Trait

```rust
trait TraitName {
    fn method_name(&self); // 无默认实现
}
```

### 实现 Trait

```rust
impl TraitName for TypeName {
    fn method_name(&self) {
        // 实现逻辑
    }
}
```

---

## 🌟 示例：定义和实现一个 Trait

```rust
trait Hello {
    fn say_hello(&self);
}

struct Person;
struct Robot;

impl Hello for Person {
    fn say_hello(&self) {
        println!("你好，我是人类！");
    }
}

impl Hello for Robot {
    fn say_hello(&self) {
        println!("你好，我是机器人！");
    }
}

fn main() {
    let p = Person;
    let r = Robot;

    p.say_hello(); // 你好，我是人类！
    r.say_hello(); // 你好，我是机器人！
}
```

---

## 🔸 默认实现

你可以为 trait 提供默认实现，这样实现者可以选择是否覆盖它。

```rust
trait Greet {
    fn greet(&self) {
        println!("Hello!");
    }
}

struct Cat;
impl Greet for Cat {} // 使用默认实现

fn main() {
    Cat.greet(); // Hello!
}
```

---

## 🔹 带返回值的方法

```rust
trait Area {
    fn area(&self) -> f64;
}

struct Circle {
    radius: f64,
}

impl Area for Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * self.radius * self.radius
    }
}
```

---

## 🧩 多个 Trait 的实现

```rust
trait A {
    fn a(&self);
}

trait B {
    fn b(&self);
}

struct Thing;

impl A for Thing {
    fn a(&self) { println!("A"); }
}

impl B for Thing {
    fn b(&self) { println!("B"); }
}
```

---

## 🎯 Trait Bound（特征约束）

可以将 trait 作为函数参数的类型约束：

### 写法 1：在参数处使用 `impl Trait`

```rust
fn print_speak(x: impl Speak) {
    x.speak();
}
```

### 写法 2：使用泛型 + `T: Trait`

```rust
fn print_speak<T: Speak>(x: T) {
    x.speak();
}
```

### 写法 3：使用 where 子句（更清晰）

```rust
fn print_speak<T>(x: T)
where
    T: Speak,
{
    x.speak();
}
```

---

## 🔐 多个 Trait Bound（组合约束）

```rust
fn show<T: Speak + std::fmt::Debug>(x: T) {
    x.speak();
    println!("{:?}", x);
}
```

---

## ✅ Trait Object（特征对象）

如果你想让一个变量“指向不同实现类型”，需要用 **trait 对象 + 动态分发**：

```rust
trait Speak {
    fn speak(&self);
}

struct Dog;
impl Speak for Dog {
    fn speak(&self) { println!("狗叫！"); }
}

struct Cat;
impl Speak for Cat {
    fn speak(&self) { println!("猫叫！"); }
}

fn make_speak_list() -> Vec<Box<dyn Speak>> {
    vec![Box::new(Dog), Box::new(Cat)]
}

fn main() {
    for animal in make_speak_list() {
        animal.speak(); // 动态调用
    }
}
```

### 注意事项：

* `Box<dyn Trait>` 是**特征对象**；
* 只有在 **Trait 没有泛型参数**时，才能作为 trait 对象；
* 运行时使用“动态分发”，稍慢但更灵活。

---

## 🚀 Trait 作为返回值

```rust
fn make_speaker() -> impl Speak {
    Dog
}
```

⚠️ 注意：`impl Trait` 只能返回 **一种实现类型**。

---

## 关联类型（Associated Types）

在 Trait 中定义类型占位符：

```rust
trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}
```

实现时必须要指定 `Item` 类型：

```rust
struct Counter;

impl Iterator for Counter {
    type Item = i32;

    fn next(&mut self) -> Option<i32> {
        Some(42)
    }
}
```

## trait 继承？

简单点说就是：**一个 trait 继承另一个 trait 的能力**。

```rust
trait A {
    fn a(&self);
}

trait B: A {
    // 这里可以直接用 A 的方法
    fn b(&self) {
        println!("b calls a:");
        self.a(); // 直接用 A 的方法
    }
}

```

但和其他编程语言的面向对象继承不同的是：**任何实现 B 的类型，也必须同时实现 A**

### 泛型继承的简单例子

```rust
struct MyType;

impl A for MyType {
    fn a(&self) { println!("hello from A"); }
}

impl B for MyType {}

fn main() {
    let t = MyType;
    t.b(); // 自动调用 a()
}
```

必须同时为 MyType 类型实现 A 和 B，下面的写法是错误的：

```rust
struct MyType;

impl B for MyType {
    // 重要：这里并没有实现 A，不能在B实现里面实现A的方法
    fn a(&self) { println!("hello from A"); }
}

fn main() {
    let t = MyType;
    t.b(); // 自动调用 a()
}
```

---

## 📦 使用标准库 Trait

Rust 标准库中大量使用 trait，比如：

| Trait           | 用途               |
| --------------- | ---------------- |
| `Display`       | 格式化输出 `{}`       |
| `Debug`         | 格式化输出 `{:?}`     |
| `Clone`         | 克隆               |
| `Copy`          | 拷贝               |
| `PartialEq`     | 相等比较 `==`        |
| `PartialOrd`    | 大小比较 `< > >= <=` |
| `From` / `Into` | 类型转换             |
| `Drop`          | 自定义析构            |

### 示例：为自定义类型实现 `Display`

```rust
use std::fmt;

struct Point { x: i32, y: i32 }

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}

fn main() {
    let p = Point { x: 1, y: 2 };
    println!("{}", p); // (1, 2)
}
```

---

## Trait 的高级用法概览

| 用法           | 说明                          |
| ------------ | --------------------------- |
| 默认方法实现       | 提供默认逻辑                      |
| 静态分发 vs 动态分发 | `impl Trait` vs `dyn Trait` |
| 泛型约束         | `T: Trait`                  |
| where 子句     | `where T: Trait1 + Trait2`  |
| 关联类型         | `type Item`                 |
| trait + 泛型组合 | `trait Iterator<T>`（目前不稳定）  |
| trait 继承     | `trait B: A {}`             |
| trait 的生命周期  | `trait TraitName + 'a`      |

