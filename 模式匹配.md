# 模式匹配

## 什么是模式（pattern）

**模式（pattern）** 是一种语法结构，用于从复杂的数据中“解构”出感兴趣的部分。它常用于：

- `match` 表达式
- `if let` / `while let`
- 函数参数
- `let` / `const` 绑定
- `for` 循环

---

## `match` 表达式

```rust
let x = 1;

match x {
    1 => println!("one"),
    2 => println!("two"),
    _ => println!("something else"),
}
```

> `match` 会检查每一个分支的模式，直到匹配为止。必须**穷举**所有可能，或用 `_` 匹配其余情况。

---

## 一、字面量匹配与 `|` 多模式匹配

在 Rust 里，**`match` 的字面量模式匹配**可以用在几类“在编译期就能确定具体值”的类型上。
换句话说，它必须是**模式（pattern）中允许出现的常量表达式**，而不是运行时值。

| 类型               | 示例                  | 限制                             |
| ------------------ | --------------------- | -------------------------------- |
| 整数               | `0`, `42`, `-1`       | 必须是编译期常量                 |
| 浮点数             | `3.14`                | 由于精度和 NaN，一般少用         |
| 布尔               | `true`, `false`       | 无限制                           |
| 字符               | `'a'`, `'\n'`         | 无限制                           |
| `&'static str`     | `"hello"`             | 必须是静态字符串字面量           |
| `const` / `static` | `MAX`, `PI`           | 必须是编译期常量                 |
| 枚举单元变体       | `Enum::Variant`       | 无限制                           |
| 复合字面量         | `(0, 0)`, `[1, 2, 3]` | 元素必须是可在模式中使用的字面量 |

---

### 基本数字类型

包括所有整数和浮点数

```rust
fn main() {
    let x = 42;

    match x {
        0 => println!("zero"),
        1 => println!("one"),
        42 => println!("the answer"),
        _ => println!("something else"),
    }
}
```

---

### 布尔值

```rust
fn main() {
    let b = true;

    match b {
        true => println!("yes"),
        false => println!("no"),
    }
}
```

---

### 字符字面量（`char`）

```rust
fn main() {
    let ch = 'a';

    match ch {
        'a' => println!("letter a"),
        'z' => println!("letter z"),
        _ => println!("other"),
    }
}
```

---

### 字符串字面量（`&'static str`）

注意：匹配的是 **字符串切片常量**，不是 `String` 动态分配的字符串。

```rust
fn main() {
    let s = "rust";

    match s {
        "rust" => println!("I love Rust!"),
        "go" => println!("I love Go!"),
        _ => println!("other language"),
    }
}
```

---

### `const` / `static` 常量

你可以匹配预先定义的常量（它们在编译期有确定值）。

```rust
const MAX: u32 = 100;

fn main() {
    let n = 100;

    match n {
        MAX => println!("hit the max"),
        _ => println!("not max"),
    }
}
```

---

### 枚举变体（尤其是无数据的单元变体）

```rust
enum Direction {
    North,
    South,
    East,
    West,
}

fn main() {
    let dir = Direction::North;

    match dir {
        Direction::North => println!("up"),
        Direction::South => println!("down"),
        _ => println!("side"),
    }
}
```

---

### 复合字面量（元组、数组）

这些也是字面量匹配，只要它们里面的元素本身是可在模式中使用的字面量。

```rust
fn main() {
    let point = (0, 1);

    match point {
        (0, 0) => println!("origin"),
        (0, y) => println!("on y-axis, y = {y}"),
        (x, 0) => println!("on x-axis, x = {x}"),
        _ => println!("elsewhere"),
    }
}
```

数组也可以：

```rust
fn main() {
    let arr = [1, 2, 3];

    match arr {
        [0, 0, 0] => println!("all zeros"),
        [1, 2, _] => println!("starts with 1, 2"),
        _ => println!("something else"),
    }
}
```

## `|` 逻辑或（多模式匹配）

```rust
let x = 1;

match x {
    1 | 2 => println!("一或二"),
    3 => println!("三"),
    _ => println!("其他"),
}
```

> `1 | 2` 表示匹配 **1 或 2**，功能相当于逻辑 “或”。`|` 不仅限于字面量，可以用于所有模式类型

---

## 🔸 二、范围匹配（`..=`）

```rust
let x = 5;

match x {
    1..=3 => println!("1 到 3"),
    4..=6 => println!("4 到 6"),
    _ => println!("其他"),
}
```

> `1..=3` 是**包含上下限**的范围匹配。

注意：只能用于整数、字符等**有序类型**。

---

## 🔸 三、变量绑定与 `@` 语法

### ✅ 基本绑定

```rust
let x = Some(8);

match x {
    Some(val) => println!("值是 {}", val),
    None => println!("没有值"),
}
```

### ✅ 使用 `@` 同时匹配和绑定

```rust
let x = 7;

match x {
    n @ 1..=5 => println!("范围内的数：{}", n),
    other => println!("其他数：{}", other),
}
```

> `n @ pattern` 的意思是：**如果匹配成功，把值绑定为变量 n。**

---

## 🔸 四、结构体、元组、数组解构

### ✅ 元组解构

```rust
let point = (1, 2);

match point {
    (0, y) => println!("x 为 0，y 为 {}", y),
    (x, 0) => println!("y 为 0，x 为 {}", x),
    (x, y) => println!("x={}, y={}", x, y),
}
```

### ✅ 数组解构

```rust
let arr = [1, 2, 3];

match arr {
    [1, _, _] => println!("首元素是 1"),
    [_, 2, _] => println!("中间是 2"),
    [a, b, c] => println!("完整数组：{a}, {b}, {c}"),
}
```

### ✅ 结构体解构

```rust
struct Person { name: String, age: u8 }

let p = Person {
    name: "Alice".to_string(),
    age: 20,
};

match p {
    Person { name, age: 0..=12 } => println!("{} 是小孩", name),
    Person { name, age } => println!("{} 是 {} 岁", name, age),
}
```

### ✅ 部分字段匹配 + `..` 忽略其他字段

```rust
struct Point { x: i32, y: i32, z: i32 }

let p = Point { x: 1, y: 2, z: 3 };

match p {
    Point { x, .. } => println!("x 是 {}", x),
}
```

---

## 🔸 五、枚举模式匹配（常见于 Option、Result）

### ✅ 匹配 `Option`

```rust
let maybe = Some("hello");

match maybe {
    Some(s) => println!("有值: {}", s),
    None => println!("无值"),
}
```

### ✅ 匹配 `Result`

```rust
let result: Result<i32, &str> = Ok(10);

match result {
    Ok(val) => println!("成功：{}", val),
    Err(e) => println!("错误：{}", e),
}
```

---

## 🔸 六、`if let` 与 `while let`

### ✅ `if let`

适合只关心某一种模式：

```rust
let name = Some("Bob");

if let Some(n) = name {
    println!("你好，{}", n);
} else {
    println!("没有名字");
}
```

### ✅ `while let`

适合在循环中逐个匹配值：

```rust
let mut stack = vec![1, 2, 3];

while let Some(top) = stack.pop() {
    println!("弹出 {}", top);
}
```

---

## 🔸 七、匹配守卫（Match Guard）

可以给 `match` 的某个分支添加额外的 `if` 条件。

```rust
let x = Some(4);

match x {
    Some(n) if n < 5 => println!("小于 5 的数：{}", n),
    Some(n) => println!("大于等于 5 的数：{}", n),
    None => println!("无值"),
}
```

---

## 🔸 八、忽略值：`_` 与 `..`

### ✅ `_` 单个字段忽略

```rust
let tuple = (1, 2, 3);

match tuple {
    (1, _, _) => println!("首元素是 1"),
    _ => println!("其他"),
}
```

### ✅ `..` 多字段忽略（结构体、元组、数组）

```rust
let arr = [1, 2, 3, 4];

match arr {
    [first, .., last] => println!("首尾：{}, {}", first, last),
}
```

```rust
struct User { id: u32, name: String, age: u8 }

let u = User { id: 1, name: "Tom".into(), age: 20 };

match u {
    User { id, .. } => println!("用户 ID 是 {}", id),
}
```

---

## 🔸 九、嵌套模式匹配

模式可以嵌套使用，例如枚举中的结构体字段：

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
}

let msg = Message::Move { x: 5, y: 6 };

match msg {
    Message::Move { x, y } => println!("移动到 ({}, {})", x, y),
    Message::Write(s) => println!("写入 {}", s),
    _ => println!("其他"),
}
```

---

## 📌 模式能用在哪？

模式不仅能用在 `match`，还可以用在这些地方：

### ✅ `let` 中

```rust
let (a, b) = (1, 2);
```

### ✅ 函数参数中

```rust
fn print_point((x, y): (i32, i32)) {
    println!("x={}, y={}", x, y);
}
```

### ✅ `for` 循环中

```rust
let vec = vec![(1, 2), (3, 4)];

for (x, y) in vec {
    println!("x={}, y={}", x, y);
}
```

---

## 🧠 总结思维导图式语法要点

| 模式类型   | 关键语法           | 示例                        |     |            |
| ---------- | ------------------ | --------------------------- | --- | ---------- |
| 字面量     | `1` `true` `"abc"` | `match x { 1 => ... }`      |     |            |
| 或模式     | \`a                | b\`                         | \`1 | 2 => ...\` |
| 范围匹配   | `a..=b`            | `1..=5 => ...`              |     |            |
| 解构元组   | `(a, b)`           | `(x, 0) => ...`             |     |            |
| 解构结构体 | `{field1, field2}` | `Point { x, y }`            |     |            |
| 忽略字段   | `_`, `..`          | `(_, y)`、`Point { x, .. }` |     |            |
| 多模式绑定 | `val @ pattern`    | `n @ 1..=5 => ...`          |     |            |
| 守卫       | `if condition`     | `Some(x) if x > 5 => ...`   |     |            |
| 嵌套模式   | 模式中包含模式     | `Some(Some(x)) => ...`      |     |            |
