# æ¨¡å¼åŒ¹é…

## ä»€ä¹ˆæ˜¯æ¨¡å¼ï¼ˆpatternï¼‰

**æ¨¡å¼ï¼ˆpatternï¼‰** æ˜¯ä¸€ç§è¯­æ³•ç»“æ„ï¼Œç”¨äºä»å¤æ‚çš„æ•°æ®ä¸­â€œè§£æ„â€å‡ºæ„Ÿå…´è¶£çš„éƒ¨åˆ†ã€‚å®ƒå¸¸ç”¨äºï¼š

- `match` è¡¨è¾¾å¼
- `if let` / `while let`
- å‡½æ•°å‚æ•°
- `let` / `const` ç»‘å®š
- `for` å¾ªç¯

---

## `match` è¡¨è¾¾å¼

```rust
let x = 1;

match x {
    1 => println!("one"),
    2 => println!("two"),
    _ => println!("something else"),
}
```

> `match` ä¼šæ£€æŸ¥æ¯ä¸€ä¸ªåˆ†æ”¯çš„æ¨¡å¼ï¼Œç›´åˆ°åŒ¹é…ä¸ºæ­¢ã€‚å¿…é¡»**ç©·ä¸¾**æ‰€æœ‰å¯èƒ½ï¼Œæˆ–ç”¨ `_` åŒ¹é…å…¶ä½™æƒ…å†µã€‚

---

## ä¸€ã€å­—é¢é‡åŒ¹é…ä¸ `|` å¤šæ¨¡å¼åŒ¹é…

åœ¨ Rust é‡Œï¼Œ**`match` çš„å­—é¢é‡æ¨¡å¼åŒ¹é…**å¯ä»¥ç”¨åœ¨å‡ ç±»â€œåœ¨ç¼–è¯‘æœŸå°±èƒ½ç¡®å®šå…·ä½“å€¼â€çš„ç±»å‹ä¸Šã€‚
æ¢å¥è¯è¯´ï¼Œå®ƒå¿…é¡»æ˜¯**æ¨¡å¼ï¼ˆpatternï¼‰ä¸­å…è®¸å‡ºç°çš„å¸¸é‡è¡¨è¾¾å¼**ï¼Œè€Œä¸æ˜¯è¿è¡Œæ—¶å€¼ã€‚

| ç±»å‹               | ç¤ºä¾‹                  | é™åˆ¶                             |
| ------------------ | --------------------- | -------------------------------- |
| æ•´æ•°               | `0`, `42`, `-1`       | å¿…é¡»æ˜¯ç¼–è¯‘æœŸå¸¸é‡                 |
| æµ®ç‚¹æ•°             | `3.14`                | ç”±äºç²¾åº¦å’Œ NaNï¼Œä¸€èˆ¬å°‘ç”¨         |
| å¸ƒå°”               | `true`, `false`       | æ— é™åˆ¶                           |
| å­—ç¬¦               | `'a'`, `'\n'`         | æ— é™åˆ¶                           |
| `&'static str`     | `"hello"`             | å¿…é¡»æ˜¯é™æ€å­—ç¬¦ä¸²å­—é¢é‡           |
| `const` / `static` | `MAX`, `PI`           | å¿…é¡»æ˜¯ç¼–è¯‘æœŸå¸¸é‡                 |
| æšä¸¾å•å…ƒå˜ä½“       | `Enum::Variant`       | æ— é™åˆ¶                           |
| å¤åˆå­—é¢é‡         | `(0, 0)`, `[1, 2, 3]` | å…ƒç´ å¿…é¡»æ˜¯å¯åœ¨æ¨¡å¼ä¸­ä½¿ç”¨çš„å­—é¢é‡ |

---

### åŸºæœ¬æ•°å­—ç±»å‹

åŒ…æ‹¬æ‰€æœ‰æ•´æ•°å’Œæµ®ç‚¹æ•°

```rust
fn main() {
    let x = 42;

    match x {
        0 => println!("zero"),
        1 => println!("one"),
        42 => println!("the answer"),
        _ => println!("something else"),
    }
}
```

---

### å¸ƒå°”å€¼

```rust
fn main() {
    let b = true;

    match b {
        true => println!("yes"),
        false => println!("no"),
    }
}
```

---

### å­—ç¬¦å­—é¢é‡ï¼ˆ`char`ï¼‰

```rust
fn main() {
    let ch = 'a';

    match ch {
        'a' => println!("letter a"),
        'z' => println!("letter z"),
        _ => println!("other"),
    }
}
```

---

### å­—ç¬¦ä¸²å­—é¢é‡ï¼ˆ`&'static str`ï¼‰

æ³¨æ„ï¼šåŒ¹é…çš„æ˜¯ **å­—ç¬¦ä¸²åˆ‡ç‰‡å¸¸é‡**ï¼Œä¸æ˜¯ `String` åŠ¨æ€åˆ†é…çš„å­—ç¬¦ä¸²ã€‚

```rust
fn main() {
    let s = "rust";

    match s {
        "rust" => println!("I love Rust!"),
        "go" => println!("I love Go!"),
        _ => println!("other language"),
    }
}
```

---

### `const` / `static` å¸¸é‡

ä½ å¯ä»¥åŒ¹é…é¢„å…ˆå®šä¹‰çš„å¸¸é‡ï¼ˆå®ƒä»¬åœ¨ç¼–è¯‘æœŸæœ‰ç¡®å®šå€¼ï¼‰ã€‚

```rust
const MAX: u32 = 100;

fn main() {
    let n = 100;

    match n {
        MAX => println!("hit the max"),
        _ => println!("not max"),
    }
}
```

---

### æšä¸¾å˜ä½“ï¼ˆå°¤å…¶æ˜¯æ— æ•°æ®çš„å•å…ƒå˜ä½“ï¼‰

```rust
enum Direction {
    North,
    South,
    East,
    West,
}

fn main() {
    let dir = Direction::North;

    match dir {
        Direction::North => println!("up"),
        Direction::South => println!("down"),
        _ => println!("side"),
    }
}
```

---

### å¤åˆå­—é¢é‡ï¼ˆå…ƒç»„ã€æ•°ç»„ï¼‰

è¿™äº›ä¹Ÿæ˜¯å­—é¢é‡åŒ¹é…ï¼Œåªè¦å®ƒä»¬é‡Œé¢çš„å…ƒç´ æœ¬èº«æ˜¯å¯åœ¨æ¨¡å¼ä¸­ä½¿ç”¨çš„å­—é¢é‡ã€‚

```rust
fn main() {
    let point = (0, 1);

    match point {
        (0, 0) => println!("origin"),
        (0, y) => println!("on y-axis, y = {y}"),
        (x, 0) => println!("on x-axis, x = {x}"),
        _ => println!("elsewhere"),
    }
}
```

æ•°ç»„ä¹Ÿå¯ä»¥ï¼š

```rust
fn main() {
    let arr = [1, 2, 3];

    match arr {
        [0, 0, 0] => println!("all zeros"),
        [1, 2, _] => println!("starts with 1, 2"),
        _ => println!("something else"),
    }
}
```

## `|` é€»è¾‘æˆ–ï¼ˆå¤šæ¨¡å¼åŒ¹é…ï¼‰

```rust
let x = 1;

match x {
    1 | 2 => println!("ä¸€æˆ–äºŒ"),
    3 => println!("ä¸‰"),
    _ => println!("å…¶ä»–"),
}
```

> `1 | 2` è¡¨ç¤ºåŒ¹é… **1 æˆ– 2**ï¼ŒåŠŸèƒ½ç›¸å½“äºé€»è¾‘ â€œæˆ–â€ã€‚`|` ä¸ä»…é™äºå­—é¢é‡ï¼Œå¯ä»¥ç”¨äºæ‰€æœ‰æ¨¡å¼ç±»å‹

---

## ğŸ”¸ äºŒã€èŒƒå›´åŒ¹é…ï¼ˆ`..=`ï¼‰

```rust
let x = 5;

match x {
    1..=3 => println!("1 åˆ° 3"),
    4..=6 => println!("4 åˆ° 6"),
    _ => println!("å…¶ä»–"),
}
```

> `1..=3` æ˜¯**åŒ…å«ä¸Šä¸‹é™**çš„èŒƒå›´åŒ¹é…ã€‚

æ³¨æ„ï¼šåªèƒ½ç”¨äºæ•´æ•°ã€å­—ç¬¦ç­‰**æœ‰åºç±»å‹**ã€‚

---

## ğŸ”¸ ä¸‰ã€å˜é‡ç»‘å®šä¸ `@` è¯­æ³•

### âœ… åŸºæœ¬ç»‘å®š

```rust
let x = Some(8);

match x {
    Some(val) => println!("å€¼æ˜¯ {}", val),
    None => println!("æ²¡æœ‰å€¼"),
}
```

### âœ… ä½¿ç”¨ `@` åŒæ—¶åŒ¹é…å’Œç»‘å®š

```rust
let x = 7;

match x {
    n @ 1..=5 => println!("èŒƒå›´å†…çš„æ•°ï¼š{}", n),
    other => println!("å…¶ä»–æ•°ï¼š{}", other),
}
```

> `n @ pattern` çš„æ„æ€æ˜¯ï¼š**å¦‚æœåŒ¹é…æˆåŠŸï¼ŒæŠŠå€¼ç»‘å®šä¸ºå˜é‡ nã€‚**

---

## ğŸ”¸ å››ã€ç»“æ„ä½“ã€å…ƒç»„ã€æ•°ç»„è§£æ„

### âœ… å…ƒç»„è§£æ„

```rust
let point = (1, 2);

match point {
    (0, y) => println!("x ä¸º 0ï¼Œy ä¸º {}", y),
    (x, 0) => println!("y ä¸º 0ï¼Œx ä¸º {}", x),
    (x, y) => println!("x={}, y={}", x, y),
}
```

### âœ… æ•°ç»„è§£æ„

```rust
let arr = [1, 2, 3];

match arr {
    [1, _, _] => println!("é¦–å…ƒç´ æ˜¯ 1"),
    [_, 2, _] => println!("ä¸­é—´æ˜¯ 2"),
    [a, b, c] => println!("å®Œæ•´æ•°ç»„ï¼š{a}, {b}, {c}"),
}
```

### âœ… ç»“æ„ä½“è§£æ„

```rust
struct Person { name: String, age: u8 }

let p = Person {
    name: "Alice".to_string(),
    age: 20,
};

match p {
    Person { name, age: 0..=12 } => println!("{} æ˜¯å°å­©", name),
    Person { name, age } => println!("{} æ˜¯ {} å²", name, age),
}
```

### âœ… éƒ¨åˆ†å­—æ®µåŒ¹é… + `..` å¿½ç•¥å…¶ä»–å­—æ®µ

```rust
struct Point { x: i32, y: i32, z: i32 }

let p = Point { x: 1, y: 2, z: 3 };

match p {
    Point { x, .. } => println!("x æ˜¯ {}", x),
}
```

---

## ğŸ”¸ äº”ã€æšä¸¾æ¨¡å¼åŒ¹é…ï¼ˆå¸¸è§äº Optionã€Resultï¼‰

### âœ… åŒ¹é… `Option`

```rust
let maybe = Some("hello");

match maybe {
    Some(s) => println!("æœ‰å€¼: {}", s),
    None => println!("æ— å€¼"),
}
```

### âœ… åŒ¹é… `Result`

```rust
let result: Result<i32, &str> = Ok(10);

match result {
    Ok(val) => println!("æˆåŠŸï¼š{}", val),
    Err(e) => println!("é”™è¯¯ï¼š{}", e),
}
```

---

## ğŸ”¸ å…­ã€`if let` ä¸ `while let`

### âœ… `if let`

é€‚åˆåªå…³å¿ƒæŸä¸€ç§æ¨¡å¼ï¼š

```rust
let name = Some("Bob");

if let Some(n) = name {
    println!("ä½ å¥½ï¼Œ{}", n);
} else {
    println!("æ²¡æœ‰åå­—");
}
```

### âœ… `while let`

é€‚åˆåœ¨å¾ªç¯ä¸­é€ä¸ªåŒ¹é…å€¼ï¼š

```rust
let mut stack = vec![1, 2, 3];

while let Some(top) = stack.pop() {
    println!("å¼¹å‡º {}", top);
}
```

---

## ğŸ”¸ ä¸ƒã€åŒ¹é…å®ˆå«ï¼ˆMatch Guardï¼‰

å¯ä»¥ç»™ `match` çš„æŸä¸ªåˆ†æ”¯æ·»åŠ é¢å¤–çš„ `if` æ¡ä»¶ã€‚

```rust
let x = Some(4);

match x {
    Some(n) if n < 5 => println!("å°äº 5 çš„æ•°ï¼š{}", n),
    Some(n) => println!("å¤§äºç­‰äº 5 çš„æ•°ï¼š{}", n),
    None => println!("æ— å€¼"),
}
```

---

## ğŸ”¸ å…«ã€å¿½ç•¥å€¼ï¼š`_` ä¸ `..`

### âœ… `_` å•ä¸ªå­—æ®µå¿½ç•¥

```rust
let tuple = (1, 2, 3);

match tuple {
    (1, _, _) => println!("é¦–å…ƒç´ æ˜¯ 1"),
    _ => println!("å…¶ä»–"),
}
```

### âœ… `..` å¤šå­—æ®µå¿½ç•¥ï¼ˆç»“æ„ä½“ã€å…ƒç»„ã€æ•°ç»„ï¼‰

```rust
let arr = [1, 2, 3, 4];

match arr {
    [first, .., last] => println!("é¦–å°¾ï¼š{}, {}", first, last),
}
```

```rust
struct User { id: u32, name: String, age: u8 }

let u = User { id: 1, name: "Tom".into(), age: 20 };

match u {
    User { id, .. } => println!("ç”¨æˆ· ID æ˜¯ {}", id),
}
```

---

## ğŸ”¸ ä¹ã€åµŒå¥—æ¨¡å¼åŒ¹é…

æ¨¡å¼å¯ä»¥åµŒå¥—ä½¿ç”¨ï¼Œä¾‹å¦‚æšä¸¾ä¸­çš„ç»“æ„ä½“å­—æ®µï¼š

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
}

let msg = Message::Move { x: 5, y: 6 };

match msg {
    Message::Move { x, y } => println!("ç§»åŠ¨åˆ° ({}, {})", x, y),
    Message::Write(s) => println!("å†™å…¥ {}", s),
    _ => println!("å…¶ä»–"),
}
```

---

## ğŸ“Œ æ¨¡å¼èƒ½ç”¨åœ¨å“ªï¼Ÿ

æ¨¡å¼ä¸ä»…èƒ½ç”¨åœ¨ `match`ï¼Œè¿˜å¯ä»¥ç”¨åœ¨è¿™äº›åœ°æ–¹ï¼š

### âœ… `let` ä¸­

```rust
let (a, b) = (1, 2);
```

### âœ… å‡½æ•°å‚æ•°ä¸­

```rust
fn print_point((x, y): (i32, i32)) {
    println!("x={}, y={}", x, y);
}
```

### âœ… `for` å¾ªç¯ä¸­

```rust
let vec = vec![(1, 2), (3, 4)];

for (x, y) in vec {
    println!("x={}, y={}", x, y);
}
```

---

## ğŸ§  æ€»ç»“æ€ç»´å¯¼å›¾å¼è¯­æ³•è¦ç‚¹

| æ¨¡å¼ç±»å‹   | å…³é”®è¯­æ³•           | ç¤ºä¾‹                        |     |            |
| ---------- | ------------------ | --------------------------- | --- | ---------- |
| å­—é¢é‡     | `1` `true` `"abc"` | `match x { 1 => ... }`      |     |            |
| æˆ–æ¨¡å¼     | \`a                | b\`                         | \`1 | 2 => ...\` |
| èŒƒå›´åŒ¹é…   | `a..=b`            | `1..=5 => ...`              |     |            |
| è§£æ„å…ƒç»„   | `(a, b)`           | `(x, 0) => ...`             |     |            |
| è§£æ„ç»“æ„ä½“ | `{field1, field2}` | `Point { x, y }`            |     |            |
| å¿½ç•¥å­—æ®µ   | `_`, `..`          | `(_, y)`ã€`Point { x, .. }` |     |            |
| å¤šæ¨¡å¼ç»‘å®š | `val @ pattern`    | `n @ 1..=5 => ...`          |     |            |
| å®ˆå«       | `if condition`     | `Some(x) if x > 5 => ...`   |     |            |
| åµŒå¥—æ¨¡å¼   | æ¨¡å¼ä¸­åŒ…å«æ¨¡å¼     | `Some(Some(x)) => ...`      |     |            |
