# 方法

## 什么是“方法”？

在 Rust 中，“**方法（method）**”是与某个**结构体、枚举或 trait 实例绑定**的函数。它们通常通过 `impl` 块来定义，用于操作该类型的值。

你可以理解为 C++ 或 Java 中的“类成员函数”。


## 方法定义的基本结构

```rust
struct User {
    name: String,
}

impl User {
    fn say_hi(&self) {
        println!("你好，我是 {}", self.name);
    }
}
```

方法定义语法说明：

```rust
fn method_name(&self) {
    // 方法体
}
```

- 必须写在 `impl TypeName` 块中。
- 第一个参数必须是 `self` | `&self` | `&mut self` （值/引用/可变引用之一）。
- 方法名遵循蛇形命名：`do_something`。

## 三种 `self` 用法：方法的接收者

Rust 没有 `this`，而是使用 `self`，可分为三种方式：

| 接收方式    | 含义说明               | 示例                          |
| ----------- | ---------------------- | ----------------------------- |
| `&self`     | 只读借用               | `fn get_name(&self)`          |
| `&mut self` | 可变借用               | `fn set_name(&mut self, ...)` |
| `self`      | 取得所有权（值的移动） | `fn consume(self)`            |

示例：三种接收方式

```rust
struct Counter { count: i32 }

impl Counter {
    fn get(&self) -> i32 {
        self.count
    }

    fn inc(&mut self) {
        self.count += 1;
    }

    fn into_inner(self) -> i32 {
        self.count
    }
}
```


## 带参数的方法

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width >= other.width && self.height >= other.height
    }
}
```


## 关联函数（不带 self）

```rust
impl Rectangle {
    fn new(width: u32, height: u32) -> Self {
        Self { width, height }
    }
}
```

- 没有 `self` 参数的函数叫**关联函数**，常用作构造器。
- 通过 `TypeName::function()` 调用。

```rust
let r = Rectangle::new(30, 50);
```


## 链式调用

方法返回 `Self` 或其他类型时可以链式调用。

```rust
struct Number(i32);

impl Number {
    fn add(self, x: i32) -> Self {
        Self(self.0 + x)
    }
    fn double(self) -> Self {
        Self(self.0 * 2)
    }
}

let result = Number(5).add(3).double(); // 结果是 (5+3)*2 = 16
```


## 静态方法 vs 实例方法

| 类型     | 是否有 `self` | 调用方式       | 作用               |
| -------- | ------------- | -------------- | ------------------ |
| 实例方法 | 有            | `对象.方法()`  | 操作对象自身       | 
| 关联函数 | 无            | `类型::函数()` | 工厂函数、工具函数 |


## 同一类型多个 `impl` 块

```rust
struct Cat;

impl Cat {
    fn meow() {
        println!("喵");
    }
}

impl Cat {
    fn jump() {
        println!("跳！");
    }
}
```

多个 `impl` 块可以拆开写，不需要一次定义完所有方法。


## 为泛型类型实现方法

```rust
struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}
```

如果方法只对特定类型有意义，可以加约束：

```rust
impl<T: std::fmt::Display> Pair<T> {
    fn display(&self) {
        println!("({}, {})", self.x, self.y);
    }
}
```


## 为枚举定义方法

```rust
enum Shape {
    Circle(f64),
    Rectangle(f64, f64),
}

impl Shape {
    fn area(&self) -> f64 {
        match self {
            Shape::Circle(r) => 3.14 * r * r,
            Shape::Rectangle(w, h) => w * h,
        }
    }
}
```


## 方法可以返回引用 / 可变引用

```rust
struct User {
    name: String,
}

impl User {
    fn name(&self) -> &str {
        &self.name
    }

    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
}
```


## 方法中使用生命周期（高级）

```rust
struct Text<'a> {
    content: &'a str,
}

impl<'a> Text<'a> {
    fn get(&self) -> &str {
        self.content
    }
}
```

当方法返回引用时，Rust 需要知道它的生命周期。


## trait 中的方法（简述）

```rust
trait Speak {
    fn speak(&self);
}

struct Dog;

impl Speak for Dog {
    fn speak(&self) {
        println!("汪！");
    }
}
```

方法也可以来自 trait，后续我们可以专门讲解 trait 与多态。



# `Self` 和 `self` 的区别


## `Self` vs `self` 的本质区别

| 项目   | 含义                                                         | 举例                  |
| ------ | ------------------------------------------------------------ | --------------------- |
| `self` | 方法中的**参数名**，表示“当前实例” （类似 Java 中的 `this`） | `fn method(&self)`    |
| `Self` | 当前类型的**类型名**（类似 Java 中的 `this.class`）          | `fn new(...) -> Self` |

通俗理解：

- `self` 是“我本人”：当前实例。
- `Self` 是“我的类型”：当前这个结构体或枚举的名字。



## `self` 的用法：方法接收者

方法的第一个参数可以是：

| 写法        | 意义       | 例子                  |
| ----------- | ---------- | --------------------- |
| `self`      | 获取所有权 | `fn take(self)`       |
| `&self`     | 只读借用   | `fn read(&self)`      |
| `&mut self` | 可变借用   | `fn write(&mut self)` |

---

## `Self` 的用法：类型的别名

```rust
impl MyType {
    fn new() -> Self { ... }           // 构造器，返回值类型
    fn take(self) -> Self { ... }      // 消费自身，返回新实例
    fn borrow(&self) -> &Self { ... }  // 借用自身，返回引用
}
```

**返回类型是当前类型**

```rust
struct Point { x: i32, y: i32 }

// 写法1：使用 Self
impl Point {
    fn new(x: i32, y: i32) -> Self {
        Self { x, y }
    }
}

// 写法2：使用类型名
impl Point {
    fn new(x: i32, y: i32) -> Point {
        Self { x, y }
    }
}
```

上面两种写法等价，`Self` 相当于 `Point`

**构造新实例（构造器）时常用**

```rust
fn reset(&self) -> Self {
    Self { x: 0, y: 0 }
}
```


## 方法不能返回 `self`

**注意：`-> self` 是非法语法！Rust 不支持以这种方式返回值。**

只支持 `-> Self`，不支持 `-> self`。因为 `self` 不是一个类型名，它是一个参数名，表示方法接收的实例。

## 为什么推荐用 `Self` 而不是类型名？

以下这些情况中 **用 `Self` 更通用、更灵活**：

泛型类型中，不确定具体类型名：

```rust
impl<T> Container<T> {
    fn new(item: T) -> Self {
        Self { item }
    }
}
```

在 `trait` 中定义方法：

```rust
trait Summable {
    fn zero() -> Self;
}
```

trait 可能会被多种类型实现。比如你是为 `Point` 实现 `Summable`，写成 `Self` 会自动推导为 `Point`。


## 总结

| 用法        | 含义                   | 是否可作返回类型 |
| ----------- | ---------------------- | ---------------- |
| `self`      | 当前实例（参数）       | ❌               |
| `&self`     | 当前实例的引用（参数） | ❌               |
| `&mut self` | 可变引用（参数）       | ❌               |
| `Self`      | 当前类型名（类型别名） | ✅               |
