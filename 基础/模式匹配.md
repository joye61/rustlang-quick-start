# 模式匹配

## 什么是模式（pattern）

**模式（pattern）** 是一种语法结构，用于从复杂的数据中“解构”出感兴趣的部分。它常用于：

- `match` 表达式
- `if let` / `while let`
- 函数参数
- `let` / `const` 绑定
- `for` 循环

## `match` 表达式

```rust
let x = 1;

match x {
    1 => println!("one"),
    2 => println!("two"),
    _ => println!("something else"),
}
```

> `match` 会检查每一个分支的模式，直到匹配为止。必须**穷举**所有可能，或用 `_` 匹配其余情况。

## 字面量匹配

在 Rust 里，**`match` 的字面量模式匹配**可以用在几类“在编译期就能确定具体值”的类型上。
换句话说，它必须是**模式（pattern）中允许出现的常量表达式**，而不是运行时值。

| 类型               | 示例                  | 限制                             |
| ------------------ | --------------------- | -------------------------------- |
| 整数               | `0`, `42`, `-1`       | 必须是编译期常量                 |
| 浮点数             | `3.14`                | 由于精度和 NaN，一般少用         |
| 布尔               | `true`, `false`       | 无限制                           |
| 字符               | `'a'`, `'\n'`         | 无限制                           |
| `&'static str`     | `"hello"`             | 必须是静态字符串字面量           |
| `const` / `static` | `MAX`, `PI`           | 必须是编译期常量                 |
| 枚举单元变体       | `Enum::Variant`       | 无限制                           |
| 复合字面量         | `(0, 0)`, `[1, 2, 3]` | 元素必须是可在模式中使用的字面量 |


### 基本数字类型

包括所有整数和浮点数

```rust
fn main() {
    let x = 42;

    match x {
        0 => println!("zero"),
        1 => println!("one"),
        42 => println!("the answer"),
        _ => println!("something else"),
    }
}
```


### 布尔值

```rust
fn main() {
    let b = true;

    match b {
        true => println!("yes"),
        false => println!("no"),
    }
}
```


### 字符字面量（`char`）

```rust
fn main() {
    let ch = 'a';

    match ch {
        'a' => println!("letter a"),
        'z' => println!("letter z"),
        _ => println!("other"),
    }
}
```


### 字符串字面量（`&'static str`）

注意：匹配的是 **字符串切片常量**，不是 `String` 动态分配的字符串。

```rust
fn main() {
    let s = "rust";

    match s {
        "rust" => println!("I love Rust!"),
        "go" => println!("I love Go!"),
        _ => println!("other language"),
    }
}
```


### `const` / `static` 常量

你可以匹配预先定义的常量（它们在编译期有确定值）。

```rust
const MAX: u32 = 100;

fn main() {
    let n = 100;

    match n {
        MAX => println!("hit the max"),
        _ => println!("not max"),
    }
}
```


### 枚举变体（尤其是无数据的单元变体）

```rust
enum Direction {
    North,
    South,
    East,
    West,
}

fn main() {
    let dir = Direction::North;

    match dir {
        Direction::North => println!("up"),
        Direction::South => println!("down"),
        _ => println!("side"),
    }
}
```


### 复合字面量（元组、数组）

这些也是字面量匹配，只要它们里面的元素本身是可在模式中使用的字面量。

```rust
fn main() {
    let point = (0, 1);

    match point {
        (0, 0) => println!("origin"),
        (0, y) => println!("on y-axis, y = {y}"),
        (x, 0) => println!("on x-axis, x = {x}"),
        _ => println!("elsewhere"),
    }
}
```

数组也可以：

```rust
fn main() {
    let arr = [1, 2, 3];

    match arr {
        [0, 0, 0] => println!("all zeros"),
        [1, 2, _] => println!("starts with 1, 2"),
        _ => println!("something else"),
    }
}
```

## `|` 逻辑或（多模式匹配）

```rust
let x = 1;

match x {
    1 | 2 => println!("一或二"),
    3 => println!("三"),
    _ => println!("其他"),
}
```

> `1 | 2` 表示匹配 **1 或 2**，功能相当于逻辑 “或”，`|` 不仅限于字面量，可以用于所有模式类型，但模式之间必须结构相容（变量名、绑定位置、绑定类型一致）


## 范围匹配（`..=`）

```rust
let x = 5;

match x {
    1..=3 => println!("1 到 3"),
    4..=6 => println!("4 到 6"),
    _ => println!("其他"),
}
```

> `1..=3` 是**包含上下限**的范围匹配。

注意：只能用于整数、字符等**有序类型**。


## 变量绑定与 `@` 语法

### 基本绑定

```rust
let x = Some(8);

match x {
    Some(val) => println!("值是 {}", val),
    None => println!("没有值"),
}
```

### 使用 `@` 同时匹配和绑定

```rust
let x = 7;

match x {
    n @ 1..=5 => println!("范围内的数：{}", n),
    other => println!("其他数：{}", other),
}
```

> `n @ pattern` 的意思是：**如果匹配成功，把值绑定为变量 n**

### 可以嵌套多个 `@` 来实现 **「多个绑定」**:

```rust
enum E {
    Pair(i32, i32),
}

fn main() {
    let v = E::Pair(3, 7);

    match v {
        both @ E::Pair(x @ 1..=5, y @ 6..=10) => {
            println!("整体: {:?}, x={}, y={}", both, x, y);
        }
        _ => println!("其他情况"),
    }
}
```

输出：

```
整体: Pair(3, 7), x=3, y=7
```

这里有三个绑定：

* both 绑定了 整个枚举值 E::Pair(3, 7)
* x 绑定了第一个字段的值（范围匹配到 3）
* y 绑定了第二个字段的值（范围匹配到 7）



## `ref` 借用绑定

在 Rust 的 `match` 或 `let` 模式绑定里，默认的绑定是 **按值绑定（move 或 copy）** 的。
比如：

```rust
let s = String::from("hello");

match s {
    x => println!("{}", x), // 这里的 x 得到的是 s 的所有权
}
// s 在这里就被 move 出去了，不能再用
```

但是很多时候我们只是想**借用它**，而不是拿走它的所有权。
这时候就可以用 `ref`。

### 基本用法

`ref` 表示“把匹配到的值按 **不可变引用** 绑定”：

```rust
let s = String::from("hello");

match s {
    ref x => println!("{}", x), // x: &String
}
// s 仍然可用
println!("{}", s);
```

这里 `ref x` 的意思是：不要拿走 `s` 的值，而是给我一个 `&s`。

### `ref mut`

如果需要可变借用，就用 `ref mut`：

```rust
let mut s = String::from("hello");

match s {
    ref mut x => {
        x.push_str(", world"); // x: &mut String
    }
}
println!("{}", s); // hello, world
```

这里 `x` 是一个可变引用，可以修改原值。

### `ref` 与 `&` 的区别

很多人容易混淆 `ref` 和 `&`，区别在于：

* **`&`** 出现在 **模式里** 时，表示要匹配一个“引用类型”。
* **`ref`** 出现在 **绑定变量前** 时，表示“我要借用它”。

来看对比：

```rust
let s = String::from("hello");
let rs = &s;

// 用 & 匹配引用
match rs {
    &val => println!("{}", val), // val: String (所有权 move 出来了!)
}

// 用 ref 借用
match s {
    ref val => println!("{}", val), // val: &String
}
```

* `&val` 会**解引用**，导致 `val` 是按值绑定（move 或 copy）。
* `ref val` 则是直接生成一个借用。

### 结合复杂模式

`ref` 常用于**复杂结构解构**时，避免 move：

```rust
#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

let p = Person {
    name: "Alice".to_string(),
    age: 18,
};

match p {
    Person { ref name, age } => {
        println!("Name by ref: {}, age: {}", name, age);
    }
}
// p.name 没有被 move，p 还能用
println!("{:?}", p);
```

这里 `ref name` 表示对 `p.name` 借用，而不是拿走所有权。


### 和 `@` 语法一起用

`ref` 可以和 `@` 结合：既匹配模式，又借用绑定。

```rust
let x = Some(String::from("hi"));

match x {
    Some(ref s @ val) => {
        // s: &String   (借用)
        // val: String  (move 出来)
        println!("s = {}, val = {}", s, val);
    }
    None => {}
}
```


### 小结

* **默认绑定是按值（move/copy）**。
* **`ref` = 借用不可变引用**。
* **`ref mut` = 借用可变引用**。
* **`&pattern` = 匹配引用类型，可能会触发 move**。
* **常见场景**：

  * 想在 `match` 中借用某个字段而不 move。
  * 解构结构体/元组时避免值被 move。
  * 与 `@` 配合，既能绑定引用又能做模式匹配。



## 结构体、元组、数组解构

### 元组解构

```rust
let point = (1, 2);

match point {
    (0, y) => println!("x 为 0，y 为 {}", y),
    (x, 0) => println!("y 为 0，x 为 {}", x),
    (x, y) => println!("x={}, y={}", x, y),
}
```

### 数组解构

```rust
let arr = [1, 2, 3];

match arr {
    [1, _, _] => println!("首元素是 1"),
    [_, 2, _] => println!("中间是 2"),
    [a, b, c] => println!("完整数组：{a}, {b}, {c}"),
}
```

### 结构体解构

```rust
struct Person { name: String, age: u8 }

let p = Person {
    name: "Alice".to_string(),
    age: 20,
};

match p {
    Person { name, age: 0..=12 } => println!("{} 是小孩", name),
    Person { name, age } => println!("{} 是 {} 岁", name, age),
}
```

### 部分字段匹配 + `..` 忽略其他字段

```rust
struct Point { x: i32, y: i32, z: i32 }

let p = Point { x: 1, y: 2, z: 3 };

match p {
    Point { x, .. } => println!("x 是 {}", x),
}
```


## 枚举模式匹配（常见于 Option、Result）

### 匹配 `Option`

```rust
let maybe = Some("hello");

match maybe {
    Some(s) => println!("有值: {}", s),
    None => println!("无值"),
}
```

### 匹配 `Result`

```rust
let result: Result<i32, &str> = Ok(10);

match result {
    Ok(val) => println!("成功：{}", val),
    Err(e) => println!("错误：{}", e),
}
```



## `if let` 与 `while let` 模式匹配

### `if let`

适合只关心某一种模式：

```rust
let name = Some("Bob");

if let Some(n) = name {
    println!("你好，{}", n);
} else {
    println!("没有名字");
}
```

### `while let`

适合在循环中逐个匹配值：

```rust
let mut stack = vec![1, 2, 3];

while let Some(top) = stack.pop() {
    println!("弹出 {}", top);
}
```


## 匹配守卫（Match Guard）

可以给 `match` 的某个分支添加额外的 `if` 条件。

```rust
let x = Some(4);

match x {
    Some(n) if n < 5 => println!("小于 5 的数：{}", n),
    Some(n) => println!("大于等于 5 的数：{}", n),
    None => println!("无值"),
}
```



## 忽略值：`_` 与 `..`

### `_` 单个字段忽略

```rust
let tuple = (1, 2, 3);

match tuple {
    (1, _, _) => println!("首元素是 1"),
    _ => println!("其他"),
}
```

### `..` 多字段忽略（结构体、元组、数组）

```rust
let arr = [1, 2, 3, 4];

match arr {
    [first, .., last] => println!("首尾：{}, {}", first, last),
}
```

```rust
struct User { id: u32, name: String, age: u8 }

let u = User { id: 1, name: "Tom".into(), age: 20 };

match u {
    User { id, .. } => println!("用户 ID 是 {}", id),
}
```


## 嵌套模式匹配

模式可以嵌套使用，例如枚举中的结构体字段：

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
}

let msg = Message::Move { x: 5, y: 6 };

match msg {
    Message::Move { x, y } => println!("移动到 ({}, {})", x, y),
    Message::Write(s) => println!("写入 {}", s),
    _ => println!("其他"),
}
```



## 总结思维导图式语法要点

| 模式类型   | 关键语法           | 示例                        |     |            |
| ---------- | ------------------ | --------------------------- | --- | ---------- |
| 字面量     | `1` `true` `"abc"` | `match x { 1 => ... }`      |     |            |
| 或模式     | \`a                | b\`                         | \`1 | 2 => ...\` |
| 范围匹配   | `a..=b`            | `1..=5 => ...`              |     |            |
| 解构元组   | `(a, b)`           | `(x, 0) => ...`             |     |            |
| 解构结构体 | `{field1, field2}` | `Point { x, y }`            |     |            |
| 忽略字段   | `_`, `..`          | `(_, y)`、`Point { x, .. }` |     |            |
| 多模式绑定 | `val @ pattern`    | `n @ 1..=5 => ...`          |     |            |
| 守卫       | `if condition`     | `Some(x) if x > 5 => ...`   |     |            |
| 嵌套模式   | 模式中包含模式     | `Some(Some(x)) => ...`      |     |            |
