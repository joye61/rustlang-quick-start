# 泛型（Generics）

## 什么是泛型？

泛型（Generics）允许你写出能适用于**多种类型**的代码，而不是为每种类型都写一遍。

比如你要写一个函数比较两个数并返回较大值，可以这样：

```rust
fn max_i32(a: i32, b: i32) -> i32 {
    if a > b { a } else { b }
}
fn max_f64(a: f64, b: f64) -> f64 {
    if a > b { a } else { b }
}
```

太重复了！使用泛型版本：

```rust
fn max<T: PartialOrd>(a: T, b: T) -> T {
    if a > b { a } else { b }
}
```

`T` 是一个“**类型参数**”，你可以把它看作函数的“类型变量”。


## 泛型语法结构

在函数中使用泛型

```rust
fn function_name<T>(arg: T) -> T {
    // 使用 T 类型的变量
}
```

* `<T>`：定义泛型参数；
* `T`：在参数、返回值中使用；
* 可用多个参数，如 `<T, U, V>`。

示例：交换两个值并返回元组

```rust
fn swap<T, U>(a: T, b: U) -> (U, T) {
    (b, a)
}

fn main() {
    let result = swap(1, "hello");
    println!("{:?}", result); // ("hello", 1)
}
```


## 泛型结构体

泛型也可以用在结构体上，让结构体字段支持不同类型。

示例：

```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 1.1, y: 2.2 };
}
```

多个类型参数：

```rust
struct Pair<T, U> {
    first: T,
    second: U,
}

let p = Pair { first: "hi", second: 42 };
```


## 泛型枚举

比如 Rust 标准库中的 `Option<T>`：

```rust
enum Option<T> {
    Some(T),
    None,
}

let some_number = Option::Some(5);
let some_text = Option::Some("hello");
```

你也可以自定义类似的泛型枚举。

## 泛型方法 & `impl<T>`

泛型可以用于实现块中：

```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}
```

也可以只为某些特定类型实现：

```rust
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
```


## 泛型约束（Trait Bounds）

有些操作（如比较大小）只适用于实现了特定 trait 的类型，因此你需要 **加 trait 限制**。示例：

```rust
fn largest<T: PartialOrd>(a: T, b: T) -> T {
    if a > b { a } else { b }
}
```

你可以给多个参数加多个 trait：

```rust
fn print_debug<T: std::fmt::Debug, U: std::fmt::Display>(t: T, u: U) {
    println!("{:?}, {}", t, u);
}
```


where 子句：可读性更高的约束写法。当有多个 trait 限制时，建议使用 `where` 子句：

```rust
fn complex<T, U>(t: T, u: U) -> String
where
    T: std::fmt::Debug + Clone,
    U: std::fmt::Display,
{
    format!("{:?} {}", t.clone(), u)
}
```


## 泛型与默认类型

你可以为泛型参数指定**默认类型**（主要用于 trait 和 impl 中）：

```rust
trait Add<Rhs = Self> {
    type Output;
    fn add(self, rhs: Rhs) -> Self::Output;
}
```

这是标准库中的 `Add` trait 的写法，表示 `Rhs` 默认就是 `Self`。


## 泛型和生命周期可以共用

你可以同时使用泛型和生命周期标注：

```rust
fn longest<'a, T: std::fmt::Display>(x: &'a str, ann: T) -> &'a str {
    println!("注释：{}", ann);
    x
}
```


## 泛型总结清单

| 用法位置     | 示例                           |
| -------- | ---------------------------- |
| 函数参数     | `fn foo<T>(x: T)`            |
| 结构体字段    | `struct Point<T> { x: T }`   |
| 枚举变体     | `enum Option<T> { Some(T) }` |
| impl 实现  | `impl<T> Struct<T> {}`       |
| trait 限制 | `T: Display + Clone`         |
| 多参数      | `<T, U, V>`                  |
| where 子句 | `where T: Debug, U: Copy`    |


## 实战示例：返回数组中最大值的泛型函数

```rust
fn find_max<T: PartialOrd + Copy>(list: &[T]) -> T {
    let mut max = list[0];
    for &item in list.iter() {
        if item > max {
            max = item;
        }
    }
    max
}

fn main() {
    let nums = vec![3, 6, 9, 2];
    println!("最大值是: {}", find_max(&nums)); // 9
}
```

> 注意：使用了 `Copy` trait，因为我们要复制值。否则就需要使用引用。


## 泛型 ≠ 动态类型

Rust 的泛型是**静态类型的**，在**编译期做类型替换并生成具体实现代码**（即 monomorphization）。


##  ** turbofish 语法**：`::<...>`

1. **构造泛型类型的值**

   ```rust
   struct MyStruct<T> { value: T }

   let x = MyStruct::<f64> { value: 3.14 }; // 指定 T = f64
   // 等价的另一种写法（靠类型标注而非turbofish）：
   let y: MyStruct<f64> = MyStruct { value: 3.14 };
   ```

2. **调用带泛型的关联函数/静态方法/枚举变体**

   ```rust
   let v = Vec::<i32>::new();          // 告诉编译器这是 Vec<i32>
   let n = Option::<i64>::None;        // None 的元素类型是 i64
   let m = std::collections::HashMap::<String, i32>::new();
   ```

3. **调用带泛型参数的函数/方法**

   ```rust
   let n = "42".parse::<i64>()?;       // 方法的类型参数
   let v = [1,2,3].into_iter().collect::<Vec<_>>(); // 指定 collect 的返回容器
   let s = std::mem::replace::<String>(&mut some, String::new());
   ```

> 关键点：**它只是在调用/使用处把“类型参数”填进去**，没有别的魔法。

