# 包（Package）与模块（Module）

## 包（Package）

包是 **一个 Cargo 项目**，通常包含：

* 一个 `Cargo.toml`（配置文件，写依赖和元信息）
* 一个 `src` 目录，里面有入口文件

一个包里可以包含：

* **0 个或 1 个库 crate**（`src/lib.rs`）
* **任意多个二进制 crate**（`src/main.rs`，或 `src/bin/xxx.rs`）

也就是说：

* `cargo new my_app` → 默认生成一个包（包含一个二进制 crate）
* `cargo new my_lib --lib` → 默认生成一个包（包含一个库 crate）


## Crate

**crate 是编译的最小单元**，就是 Rust 编译器看到的一个整体。一个 crate 可以是：

* **二进制 crate**：最终生成可执行程序（带 `fn main()`）
* **库 crate**：生成一个库（没有 `main`，但可以被别人 `use`）

注意：

* 包（package）是 Cargo 管理的概念
* crate 是 Rust 编译器管理的概念
* 一个包可以包含多个 crate



# 什么是模块（module）？

* **目的**：把代码分门别类，形成一棵“模块树”，便于隔离命名、控制可见性、组织大型项目。
* **位置**：模块存在于**crate 内部**（一个 crate 是编译单元）。`main.rs` 或 `lib.rs` 是**根模块**。

## 如何声明模块（`mod`）

### 内联模块（写在同一个文件里）

```rust
mod net {
    pub fn connect() {
        println!("connected");
    }
}

fn main() {
    net::connect();
}
```

### 文件模块（把代码分到独立文件/目录）

> 在父模块里用 `mod 子模块名;`，Rust 会去找同名文件或目录。

**方式 1：同名文件**

```
src/
 ├── main.rs         // 根模块
 └── net.rs          // 子模块文件
```

`main.rs`

```rust
mod net;             // 声明子模块（把 net.rs 编译进来）

fn main() {
    net::connect();
}
```

`net.rs`

```rust
pub fn connect() {
    println!("connected");
}
```

**方式 2：目录 + mod.rs 或同名文件**

```
src/
 ├── main.rs
 └── net/
     ├── mod.rs      // net 模块的入口（可选）
     └── client.rs   // net::client 子模块
```

`main.rs`

```rust
mod net;

fn main() {
    net::client::connect();
}
```

`net/mod.rs`

```rust
pub mod client;      // 声明子模块 net::client
```

`net/client.rs`

```rust
pub fn connect() {
    println!("client connected");
}
```

> Rust 2018 之后，两种布局都支持：
>
> * `mod net;` → `net.rs` 或 `net/mod.rs`
> * 有子模块时，常用目录结构（清晰）。
> * 同时存在 `net.rs` **和** `net/mod.rs` 会冲突。


## 可见性（默认私有）

* **默认**：模块内的一切对**父模块是私有**的。
* 对外暴露必须加 `pub`。更细粒度：

  * `pub`：对所有外部可见
  * `pub(crate)`：仅当前 crate 内可见
  * `pub(super)`：仅父模块可见
  * `pub(in 路径)`：对指定路径内可见

```rust
mod a {
    pub(crate) fn in_crate() {}
    pub(super) fn only_parent() {}
    pub(in crate::a) fn only_in_a() {}

    pub struct User {
        pub name: String,  // 字段也需要单独 pub
        age: u8,           // 私有字段
    }
}
```


## 路径与访问（绝对/相对 + `self`/`super`/`crate`）

* **绝对路径**：从 `crate::` 开始（当前 crate 根），或外部 crate 名。
* **相对路径**：从当前模块出发，可用 `self::`、`super::`。

```rust
mod a {
    pub fn f() { println!("a::f"); }

    pub mod b {
        pub fn g() { println!("a::b::g"); }
        pub fn call_parent() {
            super::f();        // 调父模块 a 的 f
            crate::a::f();     // 绝对路径
            self::g();         // 当前模块的 g
        }
    }
}

fn main() {
    a::b::call_parent();
}
```


## `use`：把路径引入到当前作用域（只是“起别名/就近使用”）

```rust
mod util {
    pub fn log() {}
    pub mod fmt { pub fn pretty() {} }
}

use crate::util::log;           // 引函数
use crate::util::fmt::pretty;   // 引子模块里的函数
use crate::util::{self, fmt};   // 同时引模块和子模块
use crate::util::fmt as format; // 别名

fn main() {
    log();
    pretty();
    format::pretty();
    util::log();
}
```

**通配导入（glob）**：`use foo::*;`

这种方式容易引入命名冲突，不推荐在库对外 API 中滥用。


## 重导出（`pub use`）：

> 内部结构可以复杂，对外只暴露整洁的 API。

```rust
mod inner {
    pub struct Engine;
    pub fn start() {}
    pub mod io { pub fn read() {} }
}

// 对外导出 API：外部只看到 api::Engine / api::start / api::read
pub mod api {
    pub use crate::inner::Engine;
    pub use crate::inner::{start, io::read};
}
```

外部使用：

```rust
use mycrate::api::{Engine, start, read};
```


## 模块与外部依赖（crate）

* **本地模块**：用 `mod` 声明 + 文件/目录提供实现。
* **外部 crate**（写在 `Cargo.toml` 里）：**不需要 `mod`**，直接 `use`。

```rust
// Cargo.toml: rand = "0.8"
use rand::Rng;             // 直接从外部 crate 引用

fn main() {
    let mut rng = rand::thread_rng();
    let n = rng.gen_range(1..=6);
    println!("roll: {n}");
}
```


## 测试模块

```rust
pub fn add(a: i32, b: i32) -> i32 { a + b }

#[cfg(test)]
mod tests {
    use super::*;  // 从父模块（被测模块）导入

    #[test]
    fn it_works() {
        assert_eq!(add(2, 3), 5);
    }
}
```

## 项目布局示例（库 + 二进制）

```
myproj/
 ├── Cargo.toml
 └── src/
     ├── lib.rs              // 库 crate（对外 API）
     ├── main.rs             // 二进制入口（可选）
     ├── api/                // 对外输出
     │   └── mod.rs
     ├── core/               // 核心实现
     │   ├── mod.rs
     │   ├── engine.rs
     │   └── io.rs
     └── utils.rs
```

`lib.rs`

```rust
pub mod core;
pub mod utils;

// 打造对外门面
pub mod api {
    pub use crate::core::engine::Engine;
    pub use crate::core::io::read;
}
```

`core/mod.rs`

```rust
pub mod engine;
pub mod io;
```

`core/engine.rs`

```rust
pub struct Engine;
impl Engine { pub fn run(&self) {} }
```

`core/io.rs`

```rust
pub fn read() {}
```

`main.rs`

```rust
use myproj::api::{Engine, read};

fn main() {
    read();
    Engine.run();
}
```

## 常见坑 & 速解

* **“cannot find module”**
  忘了在父模块里写 `mod 子模块名;`，或文件名/目录结构不匹配。
* **同时存在 `foo.rs` 和 `foo/mod.rs`**
  会冲突，二选一。
* **字段私有**
  结构体本身 `pub` 不代表字段 `pub`，需要分别标注。
* **路径写不通**
  记住：跨模块访问用**路径**（绝对 `crate::...` 或相对 `super::...` / `self::...`）；想简化路径用 `use`。
* **循环耦合**
  把双方共享的东西上移到父模块（比如 `mod common;`），双方 `use super::common::*;` 即可。
* **选择可见性级别**
  对库建议用 `pub(crate)` 控制内部可见，避免过度暴露实现细节。


## 一分钟小结

* `mod`：把源文件/目录**编译进模块树**（声明模块）。
* `use`：把某个**路径引到当前作用域**（简化书写）。
* **默认私有**，用 `pub` 系列控制可见性。
* 用 `pub use` **重导出**打造对外门面。
* 合理的**文件/目录布局**让大项目清晰好维护。

