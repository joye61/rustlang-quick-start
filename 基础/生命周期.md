# 生命周期

## 什么是生命周期？

* **生命周期（Lifetime）** 是Rust用来跟踪引用（`&`）有效范围的机制。
* 作用：保证引用永远不会指向无效内存，防止悬垂指针（dangling pointer）和野指针。
* 生命周期不会对程序运行时有任何影响，它是程序编译期的静态检查标记。

## 底层原理

这一节的会让你彻底理解生命周期：

### 引用的生命周期

引用其实就是一个指针，指向内存中**某块已经存在的数据**，使用引用时必须保证：数据还活着的时候引用才能用。

如果数据被提前清理了，而引用还在指着它，就会变成 **“悬垂指针（dangling pointer）”**：引用指向的那块内存已经变成未知状态，这时再去访问它，程序可能会出现莫名其妙的错误。

为了防止这种情况，Rust 在编译时会检查引用的作用范围，确保引用的生命周期严格短于它所指向数据的生命周期。只要这个条件不成立，编译器就会直接拒绝编译。

下面是一个错误例子，不会通过编译：

```rust
fn main() {
  let r: &str;
  {
    let x = String::from("hi");
    r = x.as_str(); 
  } // 这里 x（数据） 已经被释放，但指针 r（指针） 还在
  // println!("{}", r); // ❌ 此时 r 是一个悬垂引用，不允许访问 
}
```

### 函数返回的引用

Rust函数返回引用时，返回的引用只能来自于：

1. 输入的引用参数（比如传进来的 &str）
2. 全局静态的引用（比如字符串字面量 "hello"）

绝对不能返回函数内部创建的局部变量的引用！为什么？

```rust
// 错误示范：试图返回局部变量的引用
fn get_name() -> &str {
    let name = String::from("小明"); // 局部变量（函数结束后自动销毁！）
    &name // 返回它的引用 ❌
}

fn main() {
    let my_name = get_name(); // 拿到一个"悬垂引用"（指向已销毁的内存）
    println!("名字是: {}", my_name); // 程序直接崩溃！
}
```

> 上面这个例子实际在rust编译器编译期就无法通过，等不到程序执行崩溃

```rust
static GLOBAL: i32 = 42;

// 正确：可以返回全局静态的引用
fn get_global() -> &'static i32 {
    &GLOBAL // ✅ 全局变量有 'static 生命周期
}
```


Rust通过所有权机制解决了内存安全问题，但有时编译器单靠所有权推断不出引用的有效期，比如函数参数和返回值中涉及多个引用时，又比如结构体类型包含引用成员时，这时就需要手动标注生命周期注解了，用于告诉编译器：

* 这些引用的有效期关系是怎样的
* 返回的引用和哪个参数引用的有效期有关


### 核心原则

一句话：**引用不能活得比它指向的数据久！** 记住这条铁律，生命周期就没什么难的了。


## 生命周期语法基础

* 生命周期参数以 `'a` 的形式出现，称为**生命周期标注**，写在泛型尖括号 `<'a>` 里。
* 例子：

```rust
fn foo<'a>(x: &'a i32) -> &'a i32 {
    x
}
```

这里表示：

* `x` 是一个指向 `i32` 的引用，它的生命周期是 `'a`
* 返回值是一个生命周期同样是 `'a` 的引用
* 编译器保证返回的引用至少和 `x` 的生命周期一样长


## 常见函数生命周期示例

1、单个输入引用，返回同生命周期的引用

```rust
fn first_char<'a>(s: &'a str) -> &'a str {
    &s[0..1]
}
```

含义：返回的字符串切片的生命周期和输入 `s` 保持一致。


2、多个引用参数

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}
```

含义：

* `x` 和 `y` 的生命周期都标注为 `'a`
* 返回值引用的生命周期同样是 `'a`
* 表示返回值的生命周期和两个输入参数的**公共生命周期**一致


3、多个引用参数，生命周期不同

```rust
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
    if x.len() > y.len() { x } else { y }
}
```

这段代码会报错：

```
error[E0106]: missing lifetime specifier
```

原因是：返回值的生命周期不确定，编译器无法保证它是 `x` 或 `y` 哪一个的引用


正确写法，你必须显式指定返回值的生命周期是输入参数的某一个：

```rust
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
```

或者：

```rust
fn longest<'a>(x: &str, y: &'a str) -> &'a str {
    y
}
```


## 生命周期省略规则（Lifetime Elision）

Rust编译器有三条生命周期省略规则，可以自动推断生命周期，不用手动写：

1. 每个引用参数都有自己的生命周期参数（比如 &T 变成 &'a T）。
2. 如果只有一个引用参数，那么返回值的生命周期默认等于这个参数的生命周期。
3. 如果有多个引用参数，且其中一个是 &self 或 &mut self，那么返回值的生命周期默认等于 self 的生命周期。

省略规则示例：

```rust
// 规则 2：只有一个引用参数
// 编译器自动加上 fn get_str<'a>(s: &'a str) -> &'a str
fn get_str(s: &str) -> &str { s } 

// 规则 3：有 self
impl Foo {
    fn get(&self) -> &str { &self.name } 
    // 自动变成 fn get<'a>(&'a self) -> &'a str
}

```


## 结构体中的生命周期

如果结构体里含有引用成员，也要标注生命周期，这是因为：

**结构体本身的生命周期和它所引用的数据也有可能不一致，如果数据先被清理，那么结构体的引用成员就成了悬垂指针，也无法使用了。**

```rust
struct Book<'a> {
    title: &'a str,
}
```

含义：`Book` 结构体的实例不能比 `title` 所引用的数据活得更久。


## 生命周期与方法（`impl`）中的用法

```rust
impl<'a> Book<'a> {
    fn title(&self) -> &str {
        self.title
    }
}
```

这里的 `&self` 隐含生命周期 `'a`，返回引用生命周期同样是 `'a`。


## 复杂示例：多个生命周期参数和返回值

```rust
fn choose<'a, 'b>(x: &'a str, y: &'b str, flag: bool) -> &'a str {
    if flag { x } else { "default" }
}
```

注意：

* 返回值是 `'a`，意味着如果返回 `"default"` 这个字面量字符串，它的生命周期不符合 `'a`，这会报错。
* 你必须保证返回的引用的生命周期符合函数签名要求。


## 静态生命周期 `'static`

* `'static` 是最长生命周期，代表程序整个运行周期。
* 字符串字面量默认是 `'static`：

```rust
let s: &'static str = "hello";
```