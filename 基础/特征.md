# Trait（特征）

> Trait 是 Rust 的一个核心概念，类似其他语言的“接口”或“类型类”。它定义了一组可以被实现的**行为规范**。


## 什么是 Trait？

Trait 就是一个行为“约定”，谁实现了它，谁就具备了这套功能。

例如，我们可以定义一个可以 `speak` 的 Trait：

```rust
trait Speak {
    fn speak(&self);
}
```

谁来实现？

```rust
struct Dog;

impl Speak for Dog {
    fn speak(&self) {
        println!("汪汪！");
    }
}
```


## 基本语法

定义 Trait

```rust
trait TraitName {
    fn method_name(&self); // 无默认实现
}
```

实现 Trait

```rust
impl TraitName for TypeName {
    fn method_name(&self) {
        // 实现逻辑
    }
}
```

## 默认实现

你可以为 trait 提供默认实现，这样实现者可以选择是否覆盖它。

```rust
trait Greet {
    fn greet(&self) {
        println!("Hello!");
    }
}

struct Cat;
impl Greet for Cat {} // 使用默认实现

fn main() {
    Cat.greet(); // Hello!
}
```

## 带返回值的方法

```rust
trait Area {
    fn area(&self) -> f64;
}

struct Circle {
    radius: f64,
}

impl Area for Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * self.radius * self.radius
    }
}
```


## 多个 Trait 的实现

```rust
trait A {
    fn a(&self);
}

trait B {
    fn b(&self);
}

struct Thing;

impl A for Thing {
    fn a(&self) { println!("A"); }
}

impl B for Thing {
    fn b(&self) { println!("B"); }
}
```


## Trait Bound（特征约束）

可以将 trait 作为函数参数的类型约束：

1、在参数处使用 `impl Trait`

```rust
fn print_speak(x: impl Speak) {
    x.speak();
}
```

2、使用泛型 + `T: Trait`

```rust
fn print_speak<T: Speak>(x: T) {
    x.speak();
}
```

3、使用 where 子句（更清晰）

```rust
fn print_speak<T>(x: T)
where
    T: Speak,
{
    x.speak();
}
```

## 多个 Trait Bound（组合约束）

```rust
fn show<T: Speak + std::fmt::Debug>(x: T) {
    x.speak();
    println!("{:?}", x);
}
```


## Trait Object（特征对象）

如果你想让一个变量“指向不同实现类型”，需要用 **trait 对象 + 动态分发**：

```rust
trait Speak {
    fn speak(&self);
}

struct Dog;
impl Speak for Dog {
    fn speak(&self) { println!("狗叫！"); }
}

struct Cat;
impl Speak for Cat {
    fn speak(&self) { println!("猫叫！"); }
}

fn make_speak_list() -> Vec<Box<dyn Speak>> {
    vec![Box::new(Dog), Box::new(Cat)]
}

fn main() {
    for animal in make_speak_list() {
        animal.speak(); // 动态调用
    }
}
```

注意事项：

* `Box<dyn Trait>` 是**特征对象**；
* 只有在 **Trait 没有泛型参数**时，才能作为 trait 对象；
* 运行时使用“动态分发”，稍慢但更灵活。


## Trait 作为返回值

```rust
fn make_speaker() -> impl Speak {
    Dog
}
```

注意：`impl Trait` 只能返回 **一种实现类型**。


## 关联类型（Associated Types）

在 Trait 中定义类型占位符，关联类型通过 `::` 访问：

```rust
trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}
```

实现时必须要指定 `Item` 类型：

```rust
struct Counter;

impl Iterator for Counter {
    type Item = i32;

    fn next(&mut self) -> Option<i32> {
        Some(42)
    }
}
```

## trait 继承？

简单点说就是：**一个 trait 继承另一个 trait 的能力**。

```rust
trait A {
    fn a(&self);
}

trait B: A {
    // 这里可以直接用 A 的方法
    fn b(&self) {
        println!("b calls a:");
        self.a(); // 直接用 A 的方法
    }
}

```

但和其他编程语言的面向对象继承不同的是：**任何实现 B 的类型，也必须同时实现 A**，简单例子：

```rust
struct MyType;

impl A for MyType {
    fn a(&self) { println!("hello from A"); }
}

impl B for MyType {}

fn main() {
    let t = MyType;
    t.b(); // 自动调用 a()
}
```

必须同时为 MyType 类型实现 A 和 B，下面的写法是错误的：

```rust
struct MyType;

impl B for MyType {
    // 重要：这里并没有实现 A，不能在B实现里面实现A的方法
    fn a(&self) { println!("hello from A"); }
}

fn main() {
    let t = MyType;
    t.b(); // 自动调用 a()
}
```


# `impl Trait` 作为参数和返回值的区别？

> `impl Trait` 作为**参数**和**返回值**时确实都表示实现了某个 trait 的具体类型，但它们的**规则并不完全一样**。


## 先看结论

| 用法               | 说明                                            |
| ---------------- | --------------------------------------------- |
| `impl Trait` 参数  | 可以接受任何实现了该 trait 的具体类型，**可以是多个不同类型**（调用者决定） |
| `impl Trait` 返回值 | 只能返回**一种具体类型**（编译器必须能确定唯一类型）                |


## 作为参数：**可以是不同类型**

```rust
trait Shape {
    fn area(&self) -> f64;
}

struct Circle(f64);
struct Square(f64);

impl Shape for Circle {
    fn area(&self) -> f64 { 3.14 * self.0 * self.0 }
}

impl Shape for Square {
    fn area(&self) -> f64 { self.0 * self.0 }
}

// impl Trait 作为参数
fn print_area(shape: impl Shape) {
    println!("面积是 {}", shape.area());
}

fn main() {
    print_area(Circle(1.0)); // OK
    print_area(Square(2.0)); // 也OK
}
```

## 作为返回值：**只能返回一个具体类型**

```rust
// 错误示例：返回多种类型的 impl Trait
fn random_shape(flag: bool) -> impl Shape {
    if flag {
        Circle(1.0)
    } else {
        Square(2.0) // ❌ 编译错误：返回了不同类型
    }
}
```

错误原因：

* `impl Trait` 返回值只能是单一具体类型，编译器不能推导出“一个固定的类型”。
* 即使 `Circle` 和 `Square` 都实现了 `Shape`，也不行。


正确替代方案：使用 trait object

```rust
fn random_shape(flag: bool) -> Box<dyn Shape> {
    if flag {
        Box::new(Circle(1.0))
    } else {
        Box::new(Square(2.0))
    }
}
```


## 泛型 vs impl Trait 参数

你也可以为参数使用泛型写法，它等价于 `impl Trait`：

```rust
// 泛型写法
fn print_area<T: Shape>(shape: T) {
    println!("面积是 {}", shape.area());
}
```

> `impl Trait` 参数语法只是泛型参数写法的简化形式，功能相同


## 总结对比

| 用法                | 能否接受多种类型  | 编译时是否已知 | 是否用 trait 对象 | 性能                  |
| ----------------- | --------- | ------- | ------------ | ------------------- |
| `impl Trait` 参数   | ✅ 是       | ✅ 是     | ❌ 静态分发       | 高效                  |
| 泛型参数 `<T: Trait>` | ✅ 是       | ✅ 是     | ❌ 静态分发       | 高效                  |
| `impl Trait` 返回值  | ❌ 否（只能一种） | ✅ 是     | ❌ 静态分发       | 高效                  |
| `Box<dyn Trait>`  | ✅ 是       | ❌ 不确定   | ✅ 动态分发       | 有损性能（heap + vtable） |
