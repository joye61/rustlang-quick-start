

# 自动引用 & 自动解引用

Rust 有时候会“帮你写”一些 `&` 或 `*`，导致我们感觉“我明明没写，怎么还能跑？”。这就是 **自动引用（autoref）** 和 **自动解引用（autoderef）** 的功劳。

你可以把它理解为：

> **Rust 编译器在调用方法或传参时，会帮你自动补齐 \& 或 \*，直到能匹配上你要调用的方法或函数。**

## 自动引用（autoref）

### 概念

当一个地方需要引用（`&T` 或 `&mut T`），但你给的是值（`T`），Rust 会自动帮你加上 `&` 或 `&mut`。


### 典型场景

#### 场景 1：方法调用 `&self` / `&mut self`

```rust
struct Foo;

impl Foo {
    fn say_hi(&self) {
        println!("hi!");
    }
}

fn main() {
    let f = Foo;
    f.say_hi();       // 自动变成 (&f).say_hi()
}
```

这里 `say_hi` 要的是 `&self`，你写的是 `f.say_hi()`，编译器自动补 `&`。


#### 场景 2：函数参数

```rust
fn greet(name: &str) {
    println!("Hello, {name}!");
}

fn main() {
    let s = String::from("Rust");
    greet(&s); // 手动传引用
    greet(s);  // 自动加 &，再通过 Deref 转换成 &str
}
```

#### 场景 3：模式匹配

```rust
fn main() {
    let s = String::from("hi");
    match s {
        ref x => println!("got a reference: {x}"),
        // `ref` 关键字等价于自动加 & 
    }
}
```


### 总结（autoref）

* 自动加 `&T` 或 `&mut T`
* 发生在方法调用、函数参数、模式绑定时
* 只要缺 `&`，编译器能帮你补


## 自动解引用（autoderef）

### 概念

当调用方法或访问字段时，如果当前类型没有对应的方法/字段，编译器会尝试对它做 `*`（调用 `Deref::deref` 或剥开 `&`），直到找到能用的为止。


### 典型场景

#### 场景 1：智能指针

```rust
use std::ops::Deref;

struct MyBox<T>(T);
impl<T> Deref for MyBox<T> {
    type Target = T;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

fn main() {
    let x = MyBox(String::from("hello"));
    println!("{}", x.len()); 
    // 实际上是 (*x).len()，通过 Deref 得到 &String，再调用 len()
}
```


#### 场景 2：标准库类型

```rust
fn main() {
    let s = String::from("hello");

    // contains 定义在 &str 上，而 String 没有
    println!("{}", s.contains("he"));

    // 实际展开：(&*s).contains("he")
}
```

#### 场景 3：多层引用

```rust
struct Point { x: i32, y: i32 }
impl Point {
    fn norm(&self) -> f64 {
        ((self.x.pow(2) + self.y.pow(2)) as f64).sqrt()
    }
}

fn main() {
    let p = Point { x: 3, y: 4 };
    let p_ref_ref = &&p;

    // p_ref_ref 类型是 &&Point，没有 norm 方法
    // 编译器会自动解引用：&&Point -> &Point -> Point
    println!("{}", p_ref_ref.norm());
}
```


### 总结（autoderef）

* 自动解开一层或多层 `&`、`Box`、`Rc` 等
* 核心场景：**方法调用 `.method()`** 和 **字段访问**
* 普通引用 `&T`、`&&T` 解引用是编译器内建的
* 智能指针 `Box<T>`、`Rc<T>`、`Arc<T>` 等则靠 `Deref` trait


## Autoref + Autoderef 联合作用

这两个机制经常同时出现。

### 示例：String 调用 \&str 的方法

```rust
fn main() {
    let s = String::from("hello");
    println!("{}", s.contains("he"));
}
```

过程：

1. `s` 是 `String`，没有 `contains` 方法。
2. 编译器自动加 `&`（autoref）：得到 `&String`。
3. `&String` 通过 `Deref` 转换为 `&str`（autoderef）。
4. 找到 `contains`，调用成功。


### 示例：函数参数

```rust
fn takes_str(s: &str) {
    println!("{}", s);
}

fn main() {
    let s = String::from("world");

    takes_str(&s); // 手动写
    takes_str(s);  // 自动：String -> &String -> &str
}
```

过程：

1. 函数要 `&str`。
2. 传 `String`。
3. 编译器先加 `&`（autoref）。
4. 再解引用（Deref coercion）：`&String` -> `&str`。


## Autoderef vs Deref Coercion

很多人会混淆，这里要分清：

| 特性    | Autoderef           | Deref Coercion                      |
| ----- | ------------------- | ----------------------------------- |
| 触发场景  | **方法调用、字段访问**       | **类型匹配（函数参数、赋值、返回值）**               |
| 编译器行为 | 自动尝试 `*` 解引用，直到找到方法 | 自动调用 `Deref` 转换类型                   |
| 示例    | `Box<String>.len()` | `fn foo(s: &str)` 调用 `foo(&String)` |

可以这样理解：

* `.method()` → **autoderef**
* `fn takes(&str)` + 你传 `&String` → **Deref Coercion**


## 所有细节小结

1. **Autoref**
   * 自动加 `&` 或 `&mut`
   * 场景：方法调用、参数传递、模式匹配
2. **Autoderef**
   * 自动解 `*`，走 `Deref`，或剥开多层 `&`
   * 场景：方法调用、字段访问
3. **普通引用的特殊规则**
   * `&&&&T` → 自动剥开多层 `&`，不需要 `Deref`
4. **智能指针的规则**
   * `Box<T>`, `Rc<T>`, `Arc<T>`, `Ref<T>` 等 → 必须实现 `Deref`
   * 常见的拥有型容器（`String`, `Vec<T>`, `PathBuf`, `OsString`, `CString`）都能 Deref 到切片类型
5. **autoderef + autoref 经常连用**
   * `String` 调用 `&str` 的方法
   * 函数要 `&str`，你传 `String`
6. **编译器尝试顺序**
   * 先尝试加 `&`（autoref）
   * 再尝试解 `*`（autoderef）
   * 再尝试 `Deref Coercion`
   * 一直试，直到找到匹配的方法或参数类型（最多 128 次解引用）

## 直观比喻

你可以把 `autoref` 和 `autoderef` 想象成编译器的“万能适配器”：

* 你递给它一个插头（类型），
* 插口不对（方法签名/参数要求），
* 它会先尝试给你套一层 `&`（autoref），
* 不行的话再拆掉一层包装（autoderef），
* 直到能插上为止。
