# Rust — 格式化输出（详解，简洁明了）

下面把 Rust 中**格式化输出**的常用知识点和语法细节按主题、配示例逐条讲清。内容覆盖：常用宏、占位符与类型、格式说明符（对齐/宽度/精度/填充/标志/类型）、动态参数、自定义类型的实现、性能与经典坑。示例均为可直接编译的片段（`fn main()` 中使用即可）。

---

## 1) 常用宏与用途（一览）

* `print!` / `println!`：输出到 stdout（`println!` 自动加换行）。
* `eprint!` / `eprintln!`：输出到 stderr。
* `format!`：格式化并返回 `String`（会分配）。
* `write!` / `writeln!`：把格式化内容写入实现了写入接口的目标（`std::io::Write` 或 `std::fmt::Write` 都支持）。
* `format_args!`：构造 `Arguments`，用于高效转发格式化参数（通常和 `write!`/`print!`/自定义宏配合用）。

示例：

```rust
use std::fs::File;
use std::io::Write;

fn main() -> std::io::Result<()> {
    println!("hello {}!", "world");                 // 打印并换行
    let s = format!("{} + {} = {}", 1, 2, 3);       // 返回 String
    println!("{}", s);
    let mut f = File::create("out.txt")?;
    write!(f, "写入文件：{}", 42)?;                 // 直接写入 file（无额外 String）
    Ok(())
}
```

---

## 2) 基本占位符（Display vs Debug）

* `{}`：调用类型的 `Display`（更“用户友好”）；
* `{:?}`：调用 `Debug`（用于调试，很多类型可 `#[derive(Debug)]`）；
* `{:#?}`：`Debug` 的“漂亮打印”（多行、缩进）。

示例：

```rust
#[derive(Debug)]
struct Foo { x: i32 }

fn main() {
    let f = Foo { x: 10 };
    // println!("{}");                // 错误：Foo 没有实现 Display
    println!("{:?}", f);              // Debug: Foo { x: 10 }
    println!("{:#?}", f);             // Pretty Debug（多行）
}
```

---

## 3) 常见格式“类型”控制符（type）

常用的格式类型（在 `{...}` 的尾部写）：

* `b`：二进制，`{:b}`
* `o`：八进制，`{:o}`
* `x`：十六进制（小写），`{:x}`
* `X`：十六进制（大写），`{:X}`
* `e` / `E`：科学计数法（小 / 大写）
* `p`：指针（地址），`{:p}`
  示例：

```rust
fn main() {
    let n = 255;
    println!("bin {:b}, oct {:o}, hex {:x}, HEX {:X}", n, n, n, n);
    let x = &n;
    println!("ptr: {:p}", x);
}
```

---

## 4) 对齐 / 填充 / 宽度 / 精度（语法与示例）

格式语法的一般形式：`{[argument][:[fill][align][sign][#][0][width][.precision][type]]}`
重要字段：

* **对齐（align）**：`<`（左）、`^`（居中）、`>`（右）
* **填充（fill）**：在 `align` 前指定填充字符，例如 `{:*>8}`（用 `*` 填充，右对齐，宽度 8）
* **宽度（width）**：字段最小宽度，如 `{:8}`
* **精度（precision）**：对浮点数小数位数或对字符串的最大长度，写法 `:.N`，例如 `{:.2}`
* **零填充（0）**：数字常用 `{:08}`（宽度 8，左侧用 `0` 填充）
* **符号（sign）**：`+` 显示正号（`{:+}`），空格 ` ` 在正数前留空格（`{: }`）
* **alternate（#）**：对某些类型添加前缀或漂亮输出（如 `{: #x}` -> `0xff`；或 `:{:#?}` Pretty Debug）

实例：

```rust
fn main() {
    // 对齐与填充
    println!("{:>8}", "hi");        // 右对齐，宽度 8
    println!("{:*<8}", "hi");       // 左对齐，宽度 8，用 * 填充
    println!("{:^8}", "hi");        // 居中，宽度 8

    // 零填充与数字宽度
    println!("{:08}", 42);          // 输出 "00000042"

    // 精度（浮点）
    println!("{:.2}", 3.14159);     // 输出 "3.14"

    // 字符串截断（精度也适用于字符串）
    println!("{:.3}", "abcdef");    // 输出 "abc"

    // alternate 与 hex
    println!("{:#x}", 255);         // 输出 "0xff"

    // 带符号
    println!("{:+}", 5);            // 输出 "+5"
    println!("{: }", 5);            // 输出 " 5"（正数前有空格）
}
```

---

## 5) 动态宽度 / 精度（在运行时指定）

* 命名参数方式（推荐可读）：

```rust
let w = 6;
println!("{:width$}", "hi", width = w);       // 宽度来自变量
let p = 2;
println!("{:.precision$}", 3.14159, precision = p); // 精度来自变量
```

* 星号（位置参数）方式（`*`风格）：

```rust
println!("{:.*}", 2, 3.14159);  // 第二个参数指定精度 -> "3.14"
```

---

## 6) 转义大括号

要在输出中写 `{` 或 `}`，使用 `{{` 或 `}}`：

```rust
println!("{{}} prints braces"); // 输出: {} prints braces
```

---

## 7) 自定义类型的格式化（实现 `Display` / `Debug`）

* `Debug`：通常用 `#[derive(Debug)]`；
* `Display`：需手动实现 `std::fmt::Display`，并在 `fmt` 中使用传入的 `Formatter`（`f: &mut fmt::Formatter`），可以读取 `f.width()`、`f.precision()`、`f.alternate()` 等参数来自定义输出风格。

示例（实现 Display，并支持 `alternate`）：

```rust
use std::fmt;

struct Point { x: i32, y: i32 }

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if f.alternate() {
            // 当用 "{:#}" 或 "{:#}" 时走这里
            write!(f, "Point {{ x: {}, y: {} }}", self.x, self.y)
        } else {
            write!(f, "({}, {})", self.x, self.y)
        }
    }
}

fn main() {
    let p = Point { x: 1, y: 2 };
    println!("{}", p);      // (1, 2)
    println!("{:#}", p);    // Point { x: 1, y: 2 }
}
```

注意：若类型既未实现 `Display` 也没有 `Debug`，尝试用 `{}` 或 `{:?}` 会编译失败并提示实现对应 trait。

---

## 8) `write!` / `format_args!` 的性能提示

* `format!` 会分配 `String`；如果目标是直接写入流（文件、socket、stdout），用 `write!`/`writeln!` 可避免中间 `String` 分配。
* `format_args!` 生成的 `Arguments` 可直接传给 `write!`/`println!`/`write!`，用于实现自定义宏或转发格式化参数时非常高效。

示例：

```rust
use std::io::{self, Write};
fn log_msg(stream: &mut impl Write, msg: &str) -> io::Result<()> {
    write!(stream, "LOG: {}", msg) // 不产生额外 String
}
```

---

## 9) 常见错误与注意事项

* 使用 `{}` 时，目标类型必须实现 `Display`；使用 `{:?}` 时目标须实现 `Debug`（或 `#[derive(Debug)]`）。
* **不要混用自动占位符 `{}` 与显式索引（`{0}`/命名参数）** —— 编译器通常会报错，建议统一使用自动或显式的一种风格。
* 如果需要把格式化结果传出但又想避免分配，考虑 `format_args!` + `write!` 转发。
* `{:?}` 是给调试用的，不适合用户可见输出（格式可能会改变且通常不优美）。

---

## 10) 速查表（常用）

* `{}` — Display
* `{:?}` — Debug
* `{:#?}` — Pretty Debug（多行）
* `{:b}` / `{:o}` / `{:x}` / `{:X}` — 二/八/十六（小/大写）
* `{:e}` / `{:E}` — 科学计数法
* `{:p}` — 指针（地址）
* 对齐：`<`（左）、`^`（中）、`>`（右） — 示例 `{:>8}`
* 填充：`{:*>8}`（用 `*` 填充）
* 零填充（数字）：`{:08}`
* 精度：`{:.2}`（浮点） / `{:.3}`（字符串截断）
* 动态宽度/精度：`{:width$}`、`{:.precision$}` 或 `{:.*}`

---

## 11) 小结（要点）

* 用 `{}` 调 `Display`，`{:?}` 调 `Debug`；`{:#?}` 做“漂亮打印”。
* 格式选项顺序灵活，但常见是 `{:fill align sign #0 width.precision type}`。
* 推荐：对需要写到流的场景用 `write!` / `writeln!`（避免 `format!` 的额外分配）；在实现自定义类型时实现 `Display` 来控制用户可见输出。
* 遇到编译器格式化错误，先看是 `{}`/`{:?}` 与类型 trait 是否匹配，或是否混用了占位符风格。

---

如果你想，我可以：

* 把以上按章节生成一个可打印的 Markdown 教程（含更多示例与练习），或
* 针对你关心的某一项（比如自定义 `Display` 的高级用法、`format_args!` 的深度用法或 `Formatter` 的 API）出更详细示例。

要哪个就说一声，我马上给出具体代码和练习。

# 自动生成

#[derive(Debug)] 的自动生成，本质上是 Rust 编译器的“派生宏（derive macro）” 在编译期为你的类型生成一段实现 Debug trait 的代码。

这是因为 **Rust 的格式化输出是基于 trait 实现的**，而 `{}` 和 `{:?}` 这两种占位符分别要求你的类型实现不同的 trait：

---

## 1. Rust 的格式化机制

Rust 在编译期就会检查占位符 `{}` 或 `{:?}` 对应的 trait 是否已实现：

* `{}`  → 需要实现 [`std::fmt::Display`](https://doc.rust-lang.org/std/fmt/trait.Display.html)
* `{:?}` → 需要实现 [`std::fmt::Debug`](https://doc.rust-lang.org/std/fmt/trait.Debug.html)

如果类型没有实现对应的 trait，编译器会直接报错，而不会在运行时出错。

---

## 2. 为什么要 `#[derive(Debug)]`

假设你写了一个自定义结构体：

```rust
struct Point { x: i32, y: i32 }

fn main() {
    let p = Point { x: 1, y: 2 };
    println!("{:?}", p); // ❌ 编译错误
}
```

编译器会报：

```
`Point` doesn't implement `Debug`
```

原因：
`{:?}` 占位符会调用 `Debug` trait 的 `fmt` 方法，但你的 `Point` 没有实现它，所以编译不通过。

如果你加上：

```rust
#[derive(Debug)]
struct Point { x: i32, y: i32 }
```

Rust 编译器会**自动为你生成一个 `Debug` 的实现**，它会递归地为字段调用 `Debug` 输出，例如：

```
Point { x: 1, y: 2 }
```

---

## 3. 自动派生的前提条件

注意：
`#[derive(Debug)]` **只有在所有字段的类型也实现了 `Debug`** 时才能成功。
如果某个字段不是 `Debug`，你会得到类似的错误：

```
the trait `Debug` is not implemented for `SomeType`
```

解决：

* 给该字段的类型也 `#[derive(Debug)]` 或手动实现 `Debug`
* 或在 `Debug` 实现中跳过它（比如输出 `_`）

---

## 4. 和 `Display` 的区别

* `Debug` 主要面向开发者调试，格式固定且不一定优雅，推荐用 `#[derive(Debug)]` 快速获得。
* `Display` 面向最终用户，需要手写实现，决定输出的格式：

```rust
use std::fmt;

struct Point { x: i32, y: i32 }

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
```

---

✅ **核心结论**：
`#[derive(Debug)]` 是编译器帮你自动实现 `Debug` trait 的简写，如果你想用 `{:?}` 格式化输出自定义类型，就必须让它实现 `Debug`（自己写或用 `derive`）。

---

如果你愿意，我可以帮你画一个**Rust 格式化输出机制的流程图**，让你直观看懂 `{}` / `{:?}` 背后的 trait 调用关系。这样你会一眼看懂为什么 `derive(Debug)` 是必须的。
你要我画吗？

