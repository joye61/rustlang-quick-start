好问题 👍
# 多线程编程

## 多线程的基本概念

* **线程 (Thread)**：程序运行的最小执行单元，可以并发执行多个任务。
* **主线程**：程序入口所在的线程（`main`）。
* **子线程**：由主线程或其他线程创建，用来并行处理任务。

Rust 提供了安全的多线程抽象：`std::thread`。

## 创建线程

用 `std::thread::spawn` 创建新线程，传入一个闭包作为线程要执行的任务。

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..=5 {
            println!("子线程：第 {i} 次");
            thread::sleep(Duration::from_millis(200));
        }
    });

    for i in 1..=3 {
        println!("主线程：第 {i} 次");
        thread::sleep(Duration::from_millis(300));
    }

    handle.join().unwrap(); // 等待子线程结束
}
```

知识点：

* `thread::spawn` 返回一个 **JoinHandle**，代表子线程。
* `join()` 用来阻塞等待子线程结束，否则主线程可能先退出。

## move 捕获环境

默认情况下，线程闭包不会自动获取外部变量（因为生命周期可能不够长）。
需要用 `move` 关键字强制转移所有权。

```rust
fn main() {
    let v = vec![1, 2, 3];

    let handle = std::thread::spawn(move || {
        println!("子线程拿到 v: {:?}", v);
    });

    handle.join().unwrap();
    // println!("{:?}", v); // ❌ v 的所有权已被 move 进子线程
}
```

## 多线程数据共享

### 不可变数据共享

* Rust 里的不可变引用（`&T`）天然是**线程安全的**，多个线程可以同时读。

```rust
use std::thread;

fn main() {
    let s = "hello"; // &'static str 本身就是不可变数据
    let handle = thread::spawn(move || {
        println!("子线程读：{s}");
    });
    handle.join().unwrap();
}
```

### 可变数据共享：Mutex

* 多个线程同时写需要**互斥锁 (Mutex)** 来保护。

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0)); // 共享数据
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter); // 引用计数，安全共享
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap(); // 获取锁
            *num += 1;
        });
        handles.push(handle);
    }

    for h in handles {
        h.join().unwrap();
    }

    println!("结果 = {}", *counter.lock().unwrap());
}
```

知识点：

* `Mutex<T>`：保证同一时刻只有一个线程能访问数据。
* `Arc<T>`：原子引用计数，允许多线程共享所有权。
* 常见组合：`Arc<Mutex<T>>`


## 线程通信：Channel

Rust 提供 **消息传递（Channel）** 方式在线程间通信。

```rust
use std::sync::mpsc; // 多生产者，单消费者
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let msgs = vec!["你好", "Rust", "多线程"];
        for msg in msgs {
            tx.send(msg).unwrap();
            thread::sleep(Duration::from_millis(500));
        }
    });

    for received in rx {
        println!("主线程收到: {received}");
    }
}
```

知识点：

* `mpsc::channel()`：返回一个 `(发送端, 接收端)`。
* `send()` 发送消息，`recv()` 或 `for` 循环接收消息。
* `tx.clone()` 可以产生多个生产者。


## 线程安全（Sync & Send Trait）

* **Send**：类型能安全地在**线程间转移所有权**。
* **Sync**：类型能安全地在**多个线程中共享引用**。
* 几乎所有基础类型都实现了 `Send` + `Sync`。
  特例：`Rc<T>` 不是线程安全的（用 `Arc<T>` 代替）。


## 常见模式总结

* **一次性任务**：`thread::spawn` + `join`
* **数据共享**：`Arc<Mutex<T>>`
* **任务通信**：`mpsc::channel`
* **并发执行多个任务**：多个线程 + `join`
* **并行计算**：可用 `rayon` 库（高级抽象）

## 示例：统计多线程和消息传递

```rust
use std::sync::{mpsc, Arc, Mutex};
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for i in 0..5 {
        let tx = tx.clone();
        let counter = Arc::clone(&counter);

        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
            tx.send(format!("线程 {i} 完成")).unwrap();
        });

        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    for msg in rx {
        println!("主线程收到: {msg}");
    }

    println!("最终计数: {}", *counter.lock().unwrap());
}
```

# 总结

Rust 的多线程核心语法和知识点：

1. **创建线程**：`thread::spawn`
2. **等待线程结束**：`join`
3. **move 捕获变量**：所有权转移进线程
4. **数据共享**：`Arc<Mutex<T>>`
5. **线程通信**：`mpsc::channel`
6. **线程安全保证**：`Send` 和 `Sync` trait

