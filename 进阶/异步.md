# 什么是异步编程？

简单理解：

* **同步编程（sync）**：任务按顺序执行，一件事没做完，下一件事就得等着。
* **异步编程（async）**：任务可以挂起等待，不阻塞其他任务，CPU 可以去执行别的工作，等结果好了再回来继续。

> 比喻：
>
> * 同步：你排队买咖啡，前面的人没买完，你不能插队，也不能做别的事。
> * 异步：你去排队买咖啡，同时可以去旁边看手机或者做作业，咖啡好了有人叫你再去拿。


## 异步的基本语法


用 `async fn` 定义异步函数，返回 **Future** 对象：

```rust
async fn hello() {
    println!("Hello, async!");
}
```

* 注意：调用 `hello()` **不会立即执行**。
* 它返回一个 **Future**，代表将来的值。

```rust
fn main() {
    let f = hello(); // f 是 Future
    println!("Future created, but not run yet!");
}
```

`await` 执行 Future

要真正执行异步函数，需要用 `.await`：

```rust
use std::time::Duration;
use tokio::time::sleep;

#[tokio::main] // 异步运行时入口
async fn main() {
    println!("Start");
    sleep(Duration::from_secs(1)).await; // 挂起等待 1 秒
    println!("Done");
}
```

* `.await` 会挂起当前任务，把 CPU 空出来给其他任务。
* 注意：`await` 只能在 `async fn` 或 `async` 块里使用。

## 异步函数返回值

```rust
async fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[tokio::main]
async fn main() {
    let sum = add(2, 3).await;
    println!("sum = {}", sum);
}
```

* `async fn` 的返回类型是 `impl Future<Output=T>`
* `.await` 后得到 `T`，就是实际值。


## 并发执行多个异步任务

1、顺序执行

```rust
async fn task1() { println!("task1"); }
async fn task2() { println!("task2"); }

#[tokio::main]
async fn main() {
    task1().await;
    task2().await;
}
```

task2 等 task1 完成才开始。

2、并发执行（同时挂起）

```rust
use tokio::join;

#[tokio::main]
async fn main() {
    let t1 = async { println!("task1"); };
    let t2 = async { println!("task2"); };
    
    join!(t1, t2); // 同时执行
}
```

`join!` 会**同时启动多个 Future**，等全部完成再返回


## 异步运行时

Rust 标准库本身没有线程池/事件循环，需要 **异步运行时**（async runtime）：

常用：`tokio`、`async-std`。异步函数本身不会运行，必须交给 runtime：

```rust
#[tokio::main]  // 宏生成 runtime
async fn main() { ... }
```

或者手动创建 runtime：

```rust
let rt = tokio::runtime::Runtime::new().unwrap();
rt.block_on(hello());
```

## 异步特性总结

| 特性         | 说明                         | 示例                                        |
| ---------- | -------------------------- | ----------------------------------------- |
| `async fn` | 定义异步函数，返回 Future           | `async fn foo() -> i32 { 42 }`            |
| `.await`   | 执行 Future，挂起当前任务           | `let x = foo().await;`                    |
| `Future`   | 异步值的类型，惰性执行                | `let f: impl Future<Output=i32> = foo();` |
| 并发执行       | 用 `join!` 或 `tokio::spawn` | `join!(task1(), task2())`                 |
| 运行时        | 提供事件循环和任务调度                | `#[tokio::main]` / `Runtime::block_on()`  |


## 小结通俗口诀

1. `async fn` = “生成一个未来的值”，不会立即执行
2. `.await` = “去等待这个未来的值，挂起自己”
3. `join!` / `tokio::spawn` = “同时做多件事”
4. 运行时 = “给 Future 安排执行场所”

> 想象成：Future 是“待办事项”，`.await` 是“去完成它”，runtime 是“办公室的秘书”，可以同时安排多个待办事项。



# 为什么需要第三方运行时

Rust 的 `async/await` **是标准语法**，但它只是**语法和编译器支持**，不是完整的异步系统。

## Rust 标准库能做的事

Rust 的标准库提供：

* `async fn` / `.await` 语法
* `Future` trait（异步任务的抽象）
* `Waker` / `Context` 等底层接口

这些让你能**写出异步函数**，并且能手动 `poll` 这些 Future。


## 为什么需要第三方运行时

因为异步运行时的设计涉及：

* **事件循环（event loop）**：监听网络、定时器等事件
* **线程池调度**：并发执行多个任务
* **跨平台支持**：Windows、Linux、Mac 的 I/O API 完全不同，需要统一封装
* **异步工具**：异步锁、通道、任务取消等

这些功能不可能全部塞进 Rust 标准库（保持小而精是 Rust 的理念），所以交给第三方库来做，比如：

* **Tokio**（最流行，功能齐全，高性能）
* **async-std**（风格接近 std）
* **smol**（轻量简洁）
* **futures**（提供基础工具和简单执行器）


## 举个类比

* Rust `async`/`await`：像是**电动车的电机和控制系统**，让你能造会动的车。
* 第三方运行时（Tokio 等）：像是**车身、轮子、充电桩、道路**——帮你真正把车跑起来，还能在不同地形适应。
* 没有运行时，你只能推着车走（手动 `poll`），非常原始。