## 宏到底是啥？

你平时写的 **函数**，是运行时才会被调用的。而 **宏** 是 **在编译时“生成代码”** 的工具:

> 你告诉宏“我想要一个打印 3 次的函数”，它会直接帮你生成 3 行 `println!` 写到你的代码里。

Rust 里的 `println!`、`vec!` 都是宏，不是函数。


## 最简单的宏：`macro_rules!`

这种宏就像“模板替换”：匹配你输入的东西，然后替换成一段真正的代码。

例子：自己做一个 `say_hello!` 宏

```rust
macro_rules! say_hello {
    () => {
        println!("Hello!");
    };
}

fn main() {
    say_hello!(); // 调用时要加 !
}
```

运行结果：

```
Hello!
```

这相当于告诉编译器：
“遇到 `say_hello!()` 就把它换成 `println!("Hello!");`。”


## 宏也能接参数

例子：做一个能打印你名字的宏

```rust
macro_rules! hi {
    ($name:expr) => {
        println!("Hi, {}!", $name);
    };
}

fn main() {
    hi!("Tom");
    hi!("Alice");
}
```

输出：

```
Hi, Tom!
Hi, Alice!
```

这里的 `$name:expr` 意思是：

* `$name` 是一个变量名（宏专用的那种），
* `expr` 表示它必须是一个“表达式”。

---

## 宏能处理一堆参数

例子：批量生成 `Vec`（类似 `vec!` 宏）

```rust
macro_rules! my_vec {
    ( $( $x:expr ),* ) => {
        {
            let mut v = Vec::new();
            $(
                v.push($x);
            )*
            v
        }
    };
}

fn main() {
    let nums = my_vec![1, 2, 3, 4];
    println!("{:?}", nums);
}
```

运行结果：

```
[1, 2, 3, 4]
```

看不懂 `$( ... )*` 没关系，它的意思就是：

* `$( $x:expr ),*` → 匹配很多个表达式（中间用逗号分隔）
* `$()*` → 对匹配到的每个 `$x` 都重复里面的代码


## 宏的好处和坏处

**好处**：

* 可以少写重复代码（减少复制粘贴）
* 可以做一些普通函数做不到的语法扩展（比如 `println!` 里可以直接用 `{}`）

**坏处**：

* 可读性差（别人看不懂）
* 出错时编译报错会很长（调试不方便）

**结论**：
能用函数、泛型、trait 解决的问题，尽量不要用宏。宏留给必须“生成代码”的情况。


## 宏的两大类

Rust 里的宏分两类：

1. **声明式宏**（`macro_rules!`）
   * 就是上面这些例子
   * 简单、写法固定、功能有限
2. **过程宏**（proc-macro）
   * 更强大，可以读取代码结构（AST）并生成新的代码
   * 但要单独放在一个 crate 里写，比较复杂（比如 `#[derive(Debug)]` 就是）


## 一句话记住它

> Rust 宏 = **编译时代码生成器**
>
> * `macro_rules!`：像写模板替换，适合简单场景
> * 过程宏：像写一个编译插件，适合复杂场景



# `macro_rules!` 的基本结构

```rust
macro_rules! 名字 {
    ( matcher1 ) => { replacement1 };
    ( matcher2 ) => { replacement2 };
    // ...
}
```

* 每个 `matcher`（匹配臂）是一个模式（pattern），里面可以用 `$name:fragment` 抓取子语法片段。
* 宏调用要以 `!`：`my_macro!( ...)`。
* 宏展开是在编译期把匹配到的 `replacement` 代码“粘贴”进调用处，然后继续编译。

示例（最简单）：

```rust
macro_rules! say_hello {
    () => { println!("Hello"); };
}

fn main() {
    say_hello!();
}
```

## 元变量（metavariables）与片段说明（fragment specifiers）

在宏的模式里你会看到这种写法：`$x:expr`、`$name:ident`、`expr`、`ident` 等就是**片段说明符**，告诉编译器这个元变量能匹配什么类型的语法片段。常见的有：

* `ident` —— 标识符（变量/函数名）
* `path`  —— 路径（例如 `std::io::Result`）
* `ty`    —— 类型（`u32`, `Vec<String>`）
* `expr`  —— 表达式（`1 + 2`、`foo()`）
* `pat`   —— 模式（`Some(x)`、`(a, b)`）
* `block` —— 代码块（`{ ... }`）
* `stmt`  —— 语句
* `item`  —— 项（函数/结构体/模块定义等）
* `tt`    —— token-tree（最通用，单个 token 或括起来的 token 树）
* `literal` —— 字面量（`"hi"`, `42`）
* `vis`   —— 可见性修饰（`pub`, `pub(crate)` 等）
* `lifetime` —— 生命周期标识（`'a`）

这些片段的细节与边界很微妙（例如 `expr` 在新版 edition 有些变动），建议遇到怪问题时查官方或 TLBORM 的片段说明。

**注意（重要）**：从 Rust 的较新 Edition 起，如果在 `macro_rules!` 中写了 `$x` 而没有跟任何 `:expr` 之类的片段说明，这在新的 edition/lint 下会是错误（必须显式写片段说明）。


## 重复（repetition）与分隔符 

重复写法是 `$( ... )*`、`$( ... )+`、`$( ... )?`，通常和一个分隔符（像 `,`）配合使用：

* `$( $x:expr ),*`：匹配零个或多个以逗号分隔的 `expr`。
* `$( $x:expr ),+`：匹配至少一个。
* `$( ... )?`：可选（0 或 1 次）。

示例：实现一个简化版的 `vec!`：

```rust
macro_rules! my_vec {
    ( $( $x:expr ),* $(,)? ) => {{
        let mut v = Vec::new();
        $( v.push($x); )*
        v
    }};
}
```

* 这里 `$( v.push($x); )*` 会对每个捕获到的 `$x` 重复生成一条 `v.push(...)`。关于“不同层级的重复如何成对工作 / 分隔符规则”有专门的解释（写复杂解析器时经常踩坑）。
     |


## `#[derive(...)]` 是啥？

`derive` 不是一个函数，而是一种**编译时自动生成代码**的宏。

例子：

```rust
#[derive(Debug)]
struct User {
    name: String,
    age: u32,
}

fn main() {
    let u = User { name: "Tom".into(), age: 30 };
    println!("{:?}", u);
}
```

* `#[derive(Debug)]` 会自动帮你实现 `Debug` trait
  等于编译器自动写了：

  ```rust
  impl std::fmt::Debug for User { ... }
  ```
* 这样你就可以用 `{:?}` 打印结构体

常见可 `derive` 的 trait：

* `Debug` → 让类型可以 `{:?}` 打印
* `Clone` → 让类型能 `.clone()`
* `Copy` → 让类型支持按值复制（像整数那样）
* `PartialEq` / `Eq` → 让类型可以用 `==` 比较
* `PartialOrd` / `Ord` → 让类型可以排序、比较大小
* `Hash` → 让类型能放进 `HashMap` 这种哈希集合
* `Default` → 提供默认值 `T::default()`

## 日常常见调用宏

这些是你写 Rust 代码时最常见的宏：

| 宏名                          | 作用                       | 用法示例                              |
| --------------------------- | ------------------------ | --------------------------------- |
| `println!`                  | 打印到控制台并换行                | `println!("Hello {}", name);`     |
| `print!`                    | 打印但不换行                   | `print!("Loading...");`           |
| `format!`                   | 返回格式化后的字符串               | `let s = format!("Hi {}", name);` |
| `vec!`                      | 创建 `Vec`                 | `let v = vec![1, 2, 3];`          |
| `dbg!`                      | 调试打印（带文件名、行号）            | `dbg!(value);`                    |
| `todo!`                     | 生成一个运行时报错，提醒未实现          | `todo!("write later")`            |
| `unimplemented!`            | 同上，但语义更偏向“不打算实现”         | `unimplemented!()`                |
| `panic!`                    | 主动触发错误终止程序               | `panic!("Something went wrong")`  |
| `assert!`                   | 条件为假时 panic              | `assert!(x > 0);`                 |
| `assert_eq!` / `assert_ne!` | 比较两个值是否相等 / 不等，不符就 panic | `assert_eq!(2+2, 4);`             |

## 宏的基本规则

1. **调用宏要加 `!`**
   * `println!()` ✅
   * `println()` ❌（这是函数）
2. **参数格式要匹配**
   * 格式化字符串 `{}` 对应的参数个数要一致
3. **属性宏必须放在声明前**
   * `#[derive(Debug)] struct MyStruct;`
   * 写错位置会编译错误
4. **宏是编译时处理的**
   * 写错会在编译时报错，而不是运行时报错（调试信息有时比较长）


## 总结成一句话

> 你现在阶段只要会用**常见宏**（`println!`、`vec!`、`dbg!`、`assert_eq!`）和**属性宏**（`#[derive(...)]`），能看懂别人写的就够了。
> 宏是编译时代码生成器，日常用法就是“少写重复代码、加功能”。




