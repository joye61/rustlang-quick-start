# 迭代器 `Iterator`

## 什么是迭代器？

在 Rust 中，**迭代器是一种可以逐个产出元素的对象**。它就像一个“数据流”，可以一项一项地“取出值”，用在 for 循环、map、filter、collect 等操作中。

例如：

```rust
let nums = vec![1, 2, 3];
for n in nums.iter() {
    println!("{}", n);
}
```

## Iterator 是什么？

Rust 中的 `Iterator` 是一个 trait：

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // 默认实现的适配器方法，例如 map、filter 等
}
```

> **只要实现了 `next` 方法的类型，就是一个迭代器。**

## 最基本的迭代器使用方式

```rust
fn main() {
    let v = vec![10, 20, 30];
    let mut iter = v.iter(); // 获取不可变迭代器

    println!("{:?}", iter.next()); // Some(10)
    println!("{:?}", iter.next()); // Some(20)
    println!("{:?}", iter.next()); // Some(30)
    println!("{:?}", iter.next()); // None
}
```

## 总结

| 方法           | 含义                                |
| -------------- | ----------------------------------- |
| `.iter()`      | 获取不可变引用迭代器，类型是 `&T`   |
| `.iter_mut()`  | 获取可变引用迭代器，类型是 `&mut T` |
| `.into_iter()` | 获取所有权迭代器，类型是 `T`        |

## 实现你自己的迭代器

```rust
struct Counter {
    count: usize,
}

impl Counter {
    fn new() -> Self {
        Self { count: 0 }
    }
}

impl Iterator for Counter {
    type Item = usize;

    fn next(&mut self) -> Option<Self::Item> {
        self.count += 1;
        if self.count <= 5 {
            Some(self.count)
        } else {
            None
        }
    }
}

fn main() {
    let mut c = Counter::new();
    while let Some(n) = c.next() {
        println!("{}", n);
    }
}
```

## 总结

- 实现 `Iterator` 要定义 `type Item` 和 `next` 方法。
- `next` 每次返回 `Some(item)`，没有值时返回 `None`。
- 你可以自定义任何产生序列的逻辑。

## 常见适配器方法（map、filter、take、collect 等）

`.map()`

```rust
fn main() {
    let v = vec![1, 2, 3];
    let doubled: Vec<_> = v.iter().map(|x| x * 2).collect();
    println!("{:?}", doubled); // [2, 4, 6]
}
```

> `Vec<_>` 表示：让编译器**自动推导**出 `Vec<T>` 中的 `T` 是什么类型

`.filter()`

```rust
fn main() {
    let v = vec![1, 2, 3, 4];
    let evens: Vec<_> = v.into_iter().filter(|x| x % 2 == 0).collect();
    println!("{:?}", evens); // [2, 4]
}
```

`.take(n)`：只取前 n 个元素

```rust
fn main() {
    let nums = 1..;
    let first_five: Vec<_> = nums.take(5).collect();
    println!("{:?}", first_five); // [1, 2, 3, 4, 5]
}
```

`.collect()`：收集到集合中

```rust
fn main() {
    let squares = (1..=4).map(|x| x * x).collect::<Vec<_>>();
    println!("{:?}", squares); // [1, 4, 9, 16]
}
```

## 所有常见 Iterator 方法一览

适配器方法（返回另一个迭代器）：

- `.map()`
- `.filter()`
- `.enumerate()`
- `.skip(n)`
- `.take(n)`
- `.rev()`
- `.zip(other_iter)`
- `.chain(other_iter)`
- `.flat_map()`

消费者方法（结束迭代并返回结果）：

- `.collect()`
- `.sum()`
- `.product()`
- `.find()`
- `.any()` / `.all()`
- `.fold(init, f)`
- `.for_each()`
- `.count()`
- `.max()` / `.min()`

## `.into_iter()` 的坑点

示例：

```rust
fn main() {
    let v = vec![1, 2, 3];

    for x in v.iter() {
        println!("borrow: {}", x); // x 是 &i32
    }

    for x in v.into_iter() {
        println!("own: {}", x); // x 是 i32
    }

    let mut v2 = vec![1, 2, 3];
    for x in v2.iter_mut() {
        *x += 10;
    }
    println!("{:?}", v2); // [11, 12, 13]
}
```

总结：

| 方法           | 返回元素类型 | 是否消耗集合  |
| -------------- | ------------ | ------------- |
| `.iter()`      | `&T`         | ❌            |
| `.iter_mut()`  | `&mut T`     | ❌            |
| `.into_iter()` | `T`          | ✅ 会消耗集合 |

## `.by_ref()` 的妙用

当你想在一个方法链中“中途拿走迭代器”但又想继续用它，可以用 `.by_ref()`：

```rust
fn main() {
    let mut iter = 1..=10;

    let first_half: Vec<_> = iter.by_ref().take(5).collect();
    let second_half: Vec<_> = iter.collect();

    println!("{:?}", first_half);  // [1, 2, 3, 4, 5]
    println!("{:?}", second_half); // [6, 7, 8, 9, 10]
}
```

## `.fold()` 与 `.reduce()`

`.fold()`：累加器（初始值 + 闭包）

```rust
fn main() {
    let sum = (1..=5).fold(0, |acc, x| acc + x);
    println!("{}", sum); // 15
}
```

`.reduce()`：从第一个元素开始折叠（无初始值）

```rust
fn main() {
    let max = (1..=5).reduce(|a, b| a.max(b));
    println!("{:?}", max); // Some(5)
}
```

## `.enumerate()` 和 `.zip()`

```rust
fn main() {
    let v = vec!["a", "b", "c"];
    for (i, val) in v.iter().enumerate() {
        println!("{}: {}", i, val);
    }

    let names = ["Alice", "Bob"];
    let ages = [20, 25];
    for (name, age) in names.iter().zip(ages.iter()) {
        println!("{} is {}", name, age);
    }
}
```

## 总结：Iterator 的核心要点

| 内容             | 说明                                              |
| ---------------- | ------------------------------------------------- |
| `Iterator` trait | 定义了 `next()` 方法，用于逐个产出元素            |
| 适配器方法       | `.map()`、`.filter()`、`.take()` 等返回新的迭代器 |
| 消费者方法       | `.collect()`、`.sum()`、`.count()` 等返回最终结果 |
| 所有权规则       | `.iter()` 不消耗，`.into_iter()` 会转移所有权     |
| 可自定义实现     | 只需实现 `next()` 方法即可                        |
| 与 for 配合      | `for x in iter` 自动调用 `next()`，无需手写       |

## 与 `for` 循环的关系

Rust 的 `for x in iter {}` 是语法糖：

```rust
for x in iterable {
    println!("{}", x);
}
```

会被编译器翻译成：

```rust
let mut iter = iterable.into_iter();
while let Some(x) = iter.next() {
    println!("{}", x);
}
```

重点：**任何实现了 `IntoIterator` trait 的类型都能用于 `for` 循环语法**
