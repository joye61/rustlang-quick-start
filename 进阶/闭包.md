# 基本概念

闭包就是匿名函数，可以像变量一样存储、传递、调用。最常见写法：

```rust
fn main() {
    let add = |x: i32, y: i32| x + y; // 定义闭包
    println!("{}", add(2, 3));        // 调用闭包
}
```

区别：

- 普通函数：`fn add(x: i32, y: i32) -> i32 { x + y }`
- 闭包： `let add = |x, y| x + y;`（参数类型和返回类型可推断，通常不用写）

# 闭包的语法

三种常见写法：

```rust
let f1 = |x| x + 1;               // 简写：类型自动推断
let f2 = |x: i32| -> i32 { x + 1 }; // 明确写出参数和返回类型
let f3 = |x| {                     // 多行闭包用大括号
    println!("x={}", x);
    x + 1
};
```

调用方式：

```rust
println!("{}", f1(10)); // 11
```

闭包像变量一样，存放在栈上，可以作为参数、返回值。

# 闭包与变量捕获

闭包可以使用外部作用域的变量，这就是 **捕获**。
捕获有三种方式，编译器会**自动选择**最合适的：

1、**借用不可变引用** (`&T`)

```rust
fn main() {
    let x = 10;
    let print = || println!("x = {}", x); // 捕获 &x
    print();
    println!("x still usable: {}", x);    // x 仍然可用
}
```

2、**借用可变引用** (`&mut T`)

```rust
fn main() {
    let mut x = 10;
    let mut add = || {
        x += 1;              // 捕获 &mut x
        println!("x = {}", x);
    };
    add();
    add();
    println!("x final = {}", x);
}
```

3、 **获取所有权** (`T`)

```rust
fn main() {
    let s = String::from("hello");
    let consume = || {
        println!("consume {}", s);
        drop(s);  // 完全拿走 s
    };
    consume();
    // println!("{}", s); // ❌ 已经被拿走，不能再用
}
```

- 默认选择**最少侵入**的方式（能借用就不移动）。
- 如果想强制移动，可以用 `move` 关键字：

```rust
fn main() {
    let s = String::from("hi");
    let c = move || println!("moved: {}", s); // s 被移动进闭包
    c();
    // println!("{}", s); // ❌ s 已被移动
}
```

# 闭包的类型：Fn / FnMut / FnOnce

Rust 把闭包归纳为 3 种 trait：

1. **Fn**：只读捕获（`&T`），可以多次调用
2. **FnMut**：可变捕获（`&mut T`），可以多次调用
3. **FnOnce**：获取所有权（`T`），只能调用一次（因为变量被拿走）

例子：

```rust
fn call_fn<F: Fn()>(f: F) { f(); }
fn call_fnmut<F: FnMut()>(mut f: F) { f(); }
fn call_fnonce<F: FnOnce()>(f: F) { f(); }

fn main() {
    let x = 10;
    call_fn(|| println!("Fn: {}", x));   // 只借用，Fn

    let mut y = 0;
    call_fnmut(|| println!("FnMut: {}", y)); // 可变借用 y

    let s = String::from("abc");
    call_fnonce(|| drop(s));             // 消费 s，只能 FnOnce
}
```

闭包会自动推断成最合适的类型。比如：

- 只读 → `Fn`
- 修改外部变量 → `FnMut`
- 移动所有权 → `FnOnce`

# 闭包作为参数 / 返回值

## 作为参数：

高阶函数里常见，比如 `map`、`filter`：

```rust
fn main() {
    let nums = vec![1, 2, 3];
    let doubled: Vec<_> = nums.iter().map(|x| x * 2).collect();
    println!("{:?}", doubled); // [2,4,6]
}
```

等价于：

```rust
fn apply<F: Fn(i32) -> i32>(f: F, x: i32) -> i32 {
    f(x)
}
fn main() {
    let res = apply(|n| n + 1, 10);
    println!("{}", res); // 11
}
```

## 作为返回值

闭包类型是匿名的，不能直接写出来，需要 `impl Trait` 或 `Box`：

```rust
fn make_adder(x: i32) -> impl Fn(i32) -> i32 {
    move |y| x + y
}

fn main() {
    let add5 = make_adder(5);
    println!("{}", add5(10)); // 15
}
```

# 常见高级用法

## **`move` 闭包在线程中很常见：**

```rust
use std::thread;

fn main() {
    let v = vec![1,2,3];
    let handle = thread::spawn(move || {
        println!("vec = {:?}", v);
    });
    handle.join().unwrap();
}
```

## **存放不同闭包（需要 `Box<dyn Fn()>`）：**

```rust
fn main() {
    let mut funcs: Vec<Box<dyn Fn()>> = Vec::new();
    funcs.push(Box::new(|| println!("hello")));
    funcs.push(Box::new(|| println!("world")));

    for f in funcs {
        f();
    }
}
```

## **闭包 + sort：**

```rust
fn main() {
    let mut v = vec![3,1,2];
    v.sort_by(|a, b| a.cmp(b)); // 使用闭包比较
    println!("{:?}", v); // [1,2,3]
}
```

# 常见陷阱

1. **闭包的类型很复杂，不能直接写出来**
   必须用 `impl Trait` 或 `Box<dyn Fn...>`

2. **`move` 不是总是必须的**
   只有在所有权需要转移（比如多线程）时才用

3. **闭包不能在捕获和释放变量上“投机取巧”**
   Rust 会强制你遵守借用检查。

# 总结口诀

- 闭包就是“带环境的小函数”。
- 捕获变量时，编译器会自动决定用 `&`、`&mut` 还是移动。
- 类型分为 **Fn / FnMut / FnOnce** 三类。
- 闭包可以作为参数、返回值、存储在集合里。
- 多线程几乎必用 `move` 闭包。

# 闭包的类型表示

在 Rust 中，“**闭包的类型**”是一个比较特殊的概念：

闭包确实**有类型**，但它的类型是 **由编译器自动生成的匿名结构体**，你 **不能直接写出来**，只能通过 **trait 约束**、**`impl Trait`**、或者 **trait 对象**来间接表示。

一句话总结：

> **闭包的真实类型是唯一的、匿名的结构体，无法手写。我们用 trait（如 `Fn`）或 `impl Fn`/`Box<dyn Fn>` 来间接表示闭包类型。**

## 闭包的底层类型

每个闭包其实在底层是这样的东西，是个编译器生成的 struct：

```rust
struct MyClosure {
    captured_var1: i32,
    captured_var2: String,
}
impl Fn(i32) for MyClosure {
    extern "rust-call" fn call(&self, arg: i32) -> i32 {
        // 闭包体
    }
}
```

**这个类型是匿名的，只在编译期间可见，你没办法自己写出 `MyClosure` 这个名字。**

## 如何“表示”闭包的类型？

### 方法 1：使用泛型 + `Fn` trait 约束（最常用）

```rust
fn apply<F: Fn(i32) -> i32>(f: F, x: i32) -> i32 {
    f(x)
}
```

- 这里我们不用写闭包的具体类型，只需要说：你传进来的 `f` 实现了 `Fn(i32) -> i32` 这个 trait。
- 你也可以换成 `FnMut`、`FnOnce`，根据闭包的捕获方式。

### 方法 2：使用 `impl Fn`（返回闭包的函数）

```rust
fn make_adder(x: i32) -> impl Fn(i32) -> i32 {
    move |y| x + y
}
```

`impl Fn(...)` 是表示 “**返回某个实现了 Fn 的闭包，但我不告诉你具体类型**”。

### 方法 3：使用 trait 对象 `Box<dyn Fn...>`

```rust
fn choose_fn(flag: bool) -> Box<dyn Fn(i32) -> i32> {
    if flag {
        Box::new(|x| x + 1)
    } else {
        Box::new(|x| x + 2)
    }
}
```

- 这种方式可以把不同类型的闭包用一个指针统一处理（比如放进同一个 Vec 中），但代价是：

  - 堆分配（Box）
  - 动态分发（运行时调用）

### 总结：

| 写法                  | 含义                                  |
| --------------------- | ------------------------------------- |
| `Fn`                  | 错误 ❌（不完整，不能省略括号）                     |
| `Fn()`                | ✅ 表示闭包不接受参数                 |
| `Fn(i32)`             | ✅ 表示闭包接受一个 i32               |
| `Fn(i32) -> i32`      | ✅ 表示闭包接受一个 i32，返回一个 i32 |
| `FnMut()`, `FnOnce()` | ✅ 也同样可以带签名                   |

## 可以强转为函数指针的特殊情况

> 只有 **不捕获任何变量** 的闭包，才能转换为普通函数指针（`fn(...) -> ...`）。

```rust
fn double(x: i32) -> i32 { x * 2 }

let closure = |x: i32| x * 2; // 没有捕获任何变量
let f: fn(i32) -> i32 = closure; // ✅ 可以赋值给函数指针

fn apply_fn_ptr(f: fn(i32) -> i32) {
    println!("{}", f(5));
}
```

## 你不能这样写（错误示例）

```rust
// ❌ 编译错误：闭包没有名字，类型无法写出来
fn bad(f: |i32| -> i32) {}           // 错误语法
fn bad2(f: SomeClosureType) {}      // 没有这个类型
```

所以你必须 **用 trait 或 `impl Trait` 表达闭包的行为，而不是类型名**。

## 总结：闭包类型的表示方法一览

| 方法                         | 场景                         | 开销              |
| ---------------------------- | ---------------------------- | ----------------- |
| `F: Fn(...) -> ...`          | 最常见，适合函数参数         | 零开销（泛型）    |
| `impl Fn(...) -> ...`        | 返回闭包                     | 零开销            |
| `Box<dyn Fn(...) -> ...>`    | 运行时动态闭包（放入容器等） | 堆分配 + 动态分发 |
| `fn(...) -> ...`（函数指针） | 无捕获闭包                   | 零开销            |

一句话总结：

> `Fn(...) -> ...` 是 Rust 为了表达“这个 trait 是 **可调用** 的函数类型”而设计的一种特殊 trait 语法糖，本质上是 trait 的泛型形式，只是为了让它长得像函数签名一样直观。
