# 迭代器 `Iterator`

## 什么是迭代器？

在 Rust 中，**迭代器是一种可以逐个产出元素的对象**。它就像一个“数据流”，可以一项一项地“取出值”，用在 for 循环、map、filter、collect 等操作中。

例如：

```rust
let nums = vec![1, 2, 3];
for n in nums.iter() {
    println!("{}", n);
}
```

## Iterator 是什么？

Rust 中的 `Iterator` 是一个 trait：

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // 默认实现的适配器方法，例如 map、filter 等
}
```

> **只要实现了 `next` 方法的类型，就是一个迭代器。**


## 最基本的迭代器使用方式

```rust
fn main() {
    let v = vec![10, 20, 30];
    let mut iter = v.iter(); // 获取不可变迭代器

    println!("{:?}", iter.next()); // Some(10)
    println!("{:?}", iter.next()); // Some(20)
    println!("{:?}", iter.next()); // Some(30)
    println!("{:?}", iter.next()); // None
}
```

## 总结

| 方法             | 含义                     |
| -------------- | ---------------------- |
| `.iter()`      | 获取不可变引用迭代器，类型是 `&T`      |
| `.iter_mut()`  | 获取可变引用迭代器，类型是 `&mut T` |
| `.into_iter()` | 获取所有权迭代器，类型是 `T`       |



## 实现你自己的迭代器

```rust
struct Counter {
    count: usize,
}

impl Counter {
    fn new() -> Self {
        Self { count: 0 }
    }
}

impl Iterator for Counter {
    type Item = usize;

    fn next(&mut self) -> Option<Self::Item> {
        self.count += 1;
        if self.count <= 5 {
            Some(self.count)
        } else {
            None
        }
    }
}

fn main() {
    let mut c = Counter::new();
    while let Some(n) = c.next() {
        println!("{}", n);
    }
}
```

## 总结

* 实现 `Iterator` 要定义 `type Item` 和 `next` 方法。
* `next` 每次返回 `Some(item)`，没有值时返回 `None`。
* 你可以自定义任何产生序列的逻辑。

---

## 常见适配器方法（map、filter、take、collect 等）

### `.map()`

```rust
fn main() {
    let v = vec![1, 2, 3];
    let doubled: Vec<_> = v.iter().map(|x| x * 2).collect();
    println!("{:?}", doubled); // [2, 4, 6]
}
```

> `Vec<_>` 表示：让编译器**自动推导**出 `Vec<T>` 中的 `T` 是什么类型

### `.filter()`

```rust
fn main() {
    let v = vec![1, 2, 3, 4];
    let evens: Vec<_> = v.into_iter().filter(|x| x % 2 == 0).collect();
    println!("{:?}", evens); // [2, 4]
}
```

### `.take(n)`：只取前 n 个元素

```rust
fn main() {
    let nums = 1..;
    let first_five: Vec<_> = nums.take(5).collect();
    println!("{:?}", first_five); // [1, 2, 3, 4, 5]
}
```

### `.collect()`：收集到集合中

```rust
fn main() {
    let squares = (1..=4).map(|x| x * x).collect::<Vec<_>>();
    println!("{:?}", squares); // [1, 4, 9, 16]
}
```


## 🔂 四、所有常见 Iterator 方法一览（适配器/消费者）

### 📦 适配器方法（返回另一个迭代器）：

* `.map()`
* `.filter()`
* `.enumerate()`
* `.skip(n)`
* `.take(n)`
* `.rev()`
* `.zip(other_iter)`
* `.chain(other_iter)`
* `.flat_map()`

### 🎯 消费者方法（结束迭代并返回结果）：

* `.collect()`
* `.sum()`
* `.product()`
* `.find()`
* `.any()` / `.all()`
* `.fold(init, f)`
* `.for_each()`
* `.count()`
* `.max()` / `.min()`

---

## ✍️ 五、`.into_iter()` 的坑点（特别是 for 循环）

### 示例：

```rust
fn main() {
    let v = vec![1, 2, 3];

    for x in v.iter() {
        println!("borrow: {}", x); // x 是 &i32
    }

    for x in v.into_iter() {
        println!("own: {}", x); // x 是 i32
    }

    let mut v2 = vec![1, 2, 3];
    for x in v2.iter_mut() {
        *x += 10;
    }
    println!("{:?}", v2); // [11, 12, 13]
}
```

### ✅ 总结：

| 方法             | 返回元素类型   | 是否消耗集合  |
| -------------- | -------- | ------- |
| `.iter()`      | `&T`     | ❌       |
| `.iter_mut()`  | `&mut T` | ❌       |
| `.into_iter()` | `T`      | ✅ 会消耗集合 |

---

## 🚀 六、与 `for` 循环的关系

Rust 的 `for x in iter {}` 是语法糖：

```rust
let mut iter = some_iter;
while let Some(x) = iter.next() {
    // do something
}
```

所以你也可以自定义实现了 `Iterator` 的类型，直接用于 `for` 循环。

---

## 🧠 七、`.by_ref()` 的妙用

当你想在一个方法链中“中途拿走迭代器”但又想继续用它，可以用 `.by_ref()`：

```rust
fn main() {
    let mut iter = 1..=10;

    let first_half: Vec<_> = iter.by_ref().take(5).collect();
    let second_half: Vec<_> = iter.collect();

    println!("{:?}", first_half);  // [1, 2, 3, 4, 5]
    println!("{:?}", second_half); // [6, 7, 8, 9, 10]
}
```

---

## 🛠️ 八、`.fold()` 与 `.reduce()`

### `.fold()`：累加器（初始值 + 闭包）

```rust
fn main() {
    let sum = (1..=5).fold(0, |acc, x| acc + x);
    println!("{}", sum); // 15
}
```

### `.reduce()`：从第一个元素开始折叠（无初始值）

```rust
fn main() {
    let max = (1..=5).reduce(|a, b| a.max(b));
    println!("{:?}", max); // Some(5)
}
```

---

## 🧮 九、`.enumerate()` 和 `.zip()`

```rust
fn main() {
    let v = vec!["a", "b", "c"];
    for (i, val) in v.iter().enumerate() {
        println!("{}: {}", i, val);
    }

    let names = ["Alice", "Bob"];
    let ages = [20, 25];
    for (name, age) in names.iter().zip(ages.iter()) {
        println!("{} is {}", name, age);
    }
}
```

---

## ✅ 最终总结：Iterator 的核心要点

| 内容               | 说明                                       |
| ---------------- | ---------------------------------------- |
| `Iterator` trait | 定义了 `next()` 方法，用于逐个产出元素                 |
| 适配器方法            | `.map()`、`.filter()`、`.take()` 等返回新的迭代器  |
| 消费者方法            | `.collect()`、`.sum()`、`.count()` 等返回最终结果 |
| 所有权规则            | `.iter()` 不消耗，`.into_iter()` 会转移所有权      |
| 可自定义实现           | 只需实现 `next()` 方法即可                       |
| 与 for 配合         | `for x in iter` 自动调用 `next()`，无需手写       |

---